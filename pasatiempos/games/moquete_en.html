<!DOCTYPE html>
<html lang="en">

<head>
<link rel="shortcut icon" href="img/favicon.ico">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Help Us Slimer!</title>
  <style>
    html,body{
      margin:0;padding:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Arial;
    }
    /* Viewport */
    #viewport{
      width:100vw;height:100vh;overflow:hidden;position:relative;cursor:grab;
    }
    /* Contenedor centrado horizontalmente */
    #game-container{
      position:absolute;top:0;left:50%;transform:translateX(-50%);
      /* no tamaño fijo: el <img> define el tamaño real */
      transition: top 0.5s ease-in-out; /* TRANSICIÓN PARA EL DESPLAZAMIENTO SUAVE */
    }
    #board{
      width:100vw;height:auto;display:block;user-select:none;-webkit-user-drag:none;
    }

    /* fichas */
    .ficha{
      position:absolute;
      width:1.5vw;
      aspect-ratio:1;
      border-radius:50%;
      border:2px solid #fff;
      z-index:10;
      box-sizing:border-box;
      transform:translate(-50%,-50%); /* centrar en su punto */
      transition: all 0.5s ease-in-out; /* Animación para el movimiento suave */
    }
    /* Clase para la animación de 'levantar' la ficha */
    .ficha-levantada {
        transform: translate(calc(-50% - 15px), calc(-50% - 15px)) scale(1.4);
        z-index: 20;
    }
    
    /* Contador de vidas */
    #vidas-contenedor {
      display: flex;
      gap: 5px;
      margin-top: 10px; /* Separación de los botones */
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 8px;
    }
    .vida-icono {
      width: 40px;
      height: 40px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transition: transform 0.3s ease;
    }
    .vida-llena { background-image: url('img/corazon.png'); }
    .vida-mitad { background-image: url('img/medio_corazon.png'); }
    .vida-vacia { background-image: url('img/corazon_vacio.png'); }

    /* Contador de tiempo */
    #tiempo-contenedor {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 200;
      color: gold;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(0,0,0,0.5);
      display: none; /* Se oculta por defecto y se muestra en modo 1 jugador */
    }
    #tiempo-record {
        position: fixed;
        top: 55px;
        right: 20px;
        z-index: 200;
        color: #fff;
        font-size: 16px;
        text-shadow: 0 0 5px rgba(0,0,0,0.5);
        display: none; /* Se oculta por defecto y se muestra en modo 1 jugador */
    }
    

    /* botones de control (tirar, musica) */
    .controles {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 200;
        display: flex;
        flex-direction: column; /* Cambio a vertical */
        gap: 10px;
        align-items: flex-start; /* Alineación a la izquierda */
    }
    .controles-top {
        display: flex;
        flex-direction: row;
        gap: 10px;
        align-items: center;
    }
   .boton{
      padding:12px 20px;
      background:#444;
      color:#fff;
      border:none;
      border-radius:8px;
      cursor:pointer;
      font-size:16px;
      font-weight: bold;
      transition: transform 0.3s ease, background 0.3s ease; /* para animación */
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    /* Estilos para el botón de música con icono */
    #botonMusica {
        font-size: 20px;
        padding: 10px 15px;
    }
    .boton.animando {
      transform: scale(1.1) rotate(-10deg);
    }
    .boton:disabled {
      background: #777;
      cursor: not-allowed;
      box-shadow: none;
    }
    .boton:hover:enabled {
        background: #555;
    }

    /* Mensajes y estado */
    #mensajes-juego {
      position: fixed;
      right: 20px;
      top: 100px;
      z-index: 200;
      background: #222;
      color: #fff;
      padding: 10px;
      border-radius: 6px;
      font-size: 14px;
      min-width: 200px;
      text-align: center;
      transition: opacity 0.5s ease-out, color 0.5s ease-out;
    }
    #dado-contenedor {
        position: fixed;
        right: 20px;
        top: 180px;
        width: 60px;
        height: 60px;
        z-index: 200;
        display: none;
        perspective: 1000px;
    }
    .dado {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
    }
    .dado-cara {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #fff;
        border-radius: 8px;
        font-size: 30px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #333;
        border: 2px solid #333;
    }
    .dado-cara-1 { transform: rotateY(0deg) translateZ(30px); }
    .dado-cara-2 { transform: rotateX(90deg) translateZ(30px); }
    .dado-cara-3 { transform: rotateY(90deg) translateZ(30px); }
    .dado-cara-4 { transform: rotateY(-90deg) translateZ(30px); }
    .dado-cara-5 { transform: rotateX(-90deg) translateZ(30px); }
    .dado-cara-6 { transform: rotateY(-180deg) translateZ(30px); }
    
    .girando {
        animation: dado-girando 1s infinite linear;
    }
    @keyframes dado-girando {
        0% { transform: rotateX(0) rotateY(0) rotateZ(0); }
        100% { transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg); }
    }
    .girando-final-1 { animation: girar-a-1 1s ease-out forwards; }
    .girando-final-2 { animation: girar-a-2 1s ease-out forwards; }
    .girando-final-3 { animation: girar-a-3 1s ease-out forwards; }
    .girando-final-4 { animation: girar-a-4 1s ease-out forwards; }
    .girando-final-5 { animation: girar-a-5 1s ease-out forwards; }
    .girando-final-6 { animation: girar-a-6 1s ease-out forwards; }
    
    @keyframes girar-a-1 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(0deg) rotateX(0deg);} }
    @keyframes girar-a-2 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateX(-90deg);} }
    @keyframes girar-a-3 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(-90deg);} }
    @keyframes girar-a-4 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(90deg);} }
    @keyframes girar-a-5 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateX(90deg);} }
    @keyframes girar-a-6 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(180deg);} }

    /* modales (menu / orden / final) */
    .modal{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      background:rgba(17,17,17,0.9);
      color:#fff;padding:25px 35px;border-radius:12px;z-index:300;text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,0.8);
      min-width:280px;
    }
    .modal h3 {
        margin-top: 0;
        margin-bottom: 20px;
        color: gold;
        text-shadow: 0 0 5px rgba(255,215,0,0.5);
    }
    .modal .modal-buttons {
        margin-top: 15px;
        display: flex;
        justify-content: center;
        gap: 10px;
    }
    .modal button{
      padding:10px 20px;
      font-size:16px;
      font-weight: bold;
      cursor:pointer;
      border-radius:8px;
      border:none;
      background: linear-gradient(145deg, #444, #222);
      color: #fff;
      box-shadow: inset 0 1px 3px rgba(255,255,255,0.1), 0 5px 15px rgba(0,0,0,0.6);
      transition: all 0.2s ease;
    }
    .modal button:hover {
        background: linear-gradient(145deg, #555, #333);
        transform: translateY(-2px);
    }
    #ordenSalida .jugador-turno{margin:6px 0}
    /* animaciones */
    .brillo{animation:resplandor .5s alternate infinite;box-shadow:0 0 8px gold}
    @keyframes resplandor{from{box-shadow:0 0 8px gold}to{box-shadow:0 0 26px gold}}

    /* Nuevos resplandores para casillas */
    .casilla-resplandor {
        position: absolute;
        pointer-events: none;
        width: 3vw;
        height: 3vw;
        border-radius: 50%;
        z-index: 50;
        transform: translate(-50%,-50%);
        box-sizing: border-box;
    }
    .brillo-rojo {
        animation: resplandor-rojo 0.5s alternate infinite;
    }
    .brillo-verde {
        animation: resplandor-verde 0.5s alternate infinite;
    }
    .brillo-gozer {
        animation: resplandor-gozer 0.2s alternate infinite;
    }
    @keyframes resplandor-rojo {
        from { box-shadow: 0 0 10px 2px red; }
        to { box-shadow: 0 0 20px 8px red; }
    }
    @keyframes resplandor-verde {
        from { box-shadow: 0 0 10px 2px green; }
        to { box-shadow: 0 0 20px 8px green; }
    }
    @keyframes resplandor-gozer {
        from { box-shadow: 0 0 10px 2px #4a9fe8; }
        to { box-shadow: 0 0 30px 10px #4a9fe8; }
    }
    
    .texto-flotante{position:absolute;color:gold;font-weight:bold;pointer-events:none;text-shadow:1px 1px 4px rgba(0,0,0,0.7);z-index:400;transform:translate(-50%,-100%);animation:flotar 1.6s ease-out forwards}
    @keyframes flotar{0%{opacity:1;transform:translate(-50%,0)}100%{opacity:0;transform:translate(-50%,-50px)}}
    
    /* NUEVO: Estilos para el texto de acción especial con recuadro */
    .texto-especial {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 3vw; /* Más grande que el mensaje flotante */
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.5);
        pointer-events: none;
        z-index: 500;
        opacity: 0;
        animation: texto-accion-anim 2.5s ease-out forwards;
        background-color: rgba(0,0,0,0.7); /* Fondo semi-transparente */
        padding: 1vw 2vw; /* Relleno */
        border-radius: 1vw; /* Esquinas redondeadas */
        white-space: nowrap; /* Para que el texto no se rompa */
    }
    @keyframes texto-accion-anim {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
    }
    
    /* Fantasma */
    .fantasma {
        position: absolute;
        width: 100px;
        height: 100px;
        background-image: url('img/fantasma.gif');
        background-size: contain;
        background-repeat: no-repeat;
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.5s ease;
    }
    
    /* Animación de desaparición del fantasma */
    .fantasma-colision {
        animation: fadeOutScale 0.7s forwards;
    }
    @keyframes fadeOutScale {
        from { opacity: 1; transform: scale(1); }
        to { opacity: 0; transform: scale(1.5); }
    }
    
    /* Perro del Infierno */
    .perro-infierno {
        position: absolute;
        width: 7.5vw;
        height: 7.5vw;
        background-image: url('img/perro_infierno.gif');
        background-size: contain;
        background-repeat: no-repeat;
        pointer-events: none;
        z-index: 100;
        opacity: 0; /* Por defecto oculto */
        transition: all 0.5s ease-in-out;
        transform: translate(-50%, -50%);
    }


  </style>
</head>
<body>
  
  <audio id="audio-musica-inicio" src="sonidos/000.mp3" preload="auto" loop></audio>
  <audio id="audio-subida-1" src="sonidos/001.mp3" preload="auto"></audio>
  <audio id="audio-subida-2" src="sonidos/002.mp3" preload="auto"></audio>
  <audio id="audio-bajada-1" src="sonidos/003.mp3" preload="auto"></audio>
  <audio id="audio-bajada-2" src="sonidos/004.mp3" preload="auto"></audio>
  <audio id="audio-gozer" src="sonidos/005.mp3" preload="auto"></audio>
  <audio id="audio-dado-6" src="sonidos/006.mp3" preload="auto"></audio>
  <audio id="audio-llegada-meta" src="sonidos/007.mp3" preload="auto"></audio>
  <audio id="audio-tirada" src="sonidos/008.mp3" preload="auto"></audio>
  <audio id="audio-fantasma" src="sonidos/009.mp3" preload="auto"></audio>
  <audio id="audio-perro" src="sonidos/010.mp3" preload="auto"></audio>


  <div id="startMenu" class="modal">
    <h3>Help Us Slimer!</h3>
    <div class="modal-buttons">
      <button onclick="iniciarMenuJuego()">Start Playing!</button>
    </div>
  </div>

  <div id="menu" class="modal" style="display:none;">
    <h3>Select number of players</h3>
    <div class="modal-buttons">
      <button onclick="prepararOrden(1)">1 Player</button>
      <button onclick="prepararOrden(2)">2 Players</button>
      <button onclick="prepararOrden(3)">3 Players</button>
      <button onclick="prepararOrden(4)">4 Players</button>
    </div>
  </div>

  <div id="ordenSalida" class="modal" style="display:none;">
    <div id="textoOrden"></div>
    <div id="valeWrap" class="modal-buttons" style="display:none;">
      <button onclick="confirmarOrden()">OK</button>
    </div>
  </div>

  <div id="finalModal" class="modal" style="display:none;"></div>
  
  <div id="tiempo-contenedor">00:00</div>
  <div id="tiempo-record"></div>

  <div class="controles">
    <div class="controles-top">
      <button id="botonMusica" class="boton" onclick="toggleMusica()"></button>
      <button id="botonTirar" class="boton" style="display:none;" onclick="simularTirada()">Roll Dice</button>
    </div>
    <div id="vidas-contenedor" style="display:none;">
      <div class="vida-icono" id="vida1"></div>
      <div class="vida-icono" id="vida2"></div>
      <div class="vida-icono" id="vida3"></div>
    </div>
  </div>

  <div id="mensajes-juego" style="display:none;"></div>
  
  <div id="dado-contenedor">
    <div id="dado" class="dado">
      <div class="dado-cara dado-cara-1">1</div>
      <div class="dado-cara dado-cara-2">2</div>
      <div class="dado-cara dado-cara-3">3</div>
      <div class="dado-cara dado-cara-4">4</div>
      <div class="dado-cara dado-cara-5">5</div>
      <div class="dado-cara dado-cara-6">6</div>
    </div>
  </div>

  <div id="viewport">
    <div id="game-container">
      <img id="board" src="img/tablero.png" alt="Board">
    </div>
  </div>

<script>
/* --------- Datos y estado ---------- */
const diseñoOriginal = { width: 5315, height: 3780 };
const colores = ["#e84a4a","#4a9fe8","#4ae89f","#e8d14a"]; // rojo, azul, verde, amarillo
const nombresColores = {
  "#e84a4a": "Red",
  "#4a9fe8": "Blue",
  "#4ae89f": "Green",
  "#e8d14a": "Yellow",
  "perro": "Hell Hound"
};
const coords = [
  [630,3413],[618,2884],[672,2566],[870,2313],[1165,2229],[1441,2355],[1669,2590],[1885,2860],[2070,3100],[2324,3317],
  [2630,3417],[2936,3359],[3213,3191],[3345,2890],[3291,2572],[3080,2325],[2810,2151],[2522,2055],[2216,1983],[1899,1899],
  [1580,1832],[1273,1790],[954,1700],[660,1532],[504,1280],[450,973],[546,667],[764,431],[1069,312],[1387,300],
  [1705,348],[2005,426],[2294,552],[2576,739],[2816,931],[3026,1183],[3201,1442],[3375,1730],[3513,2019],[3651,2295],
  [3783,2584],[3927,2884],[4101,3151],[4348,3353],[4660,3370],[4936,3220],[5050,2914],[5008,2608],[4882,2301],[4690,2025],
  [4492,1790],[4258,1586],[3879,1280]
];
const especiales = {
  2: {destino:23, tipo:'avance'},
  19: {destino:32, tipo:'avance'},
  18: {destino:6, tipo:'retroceso'},
  11: {destino:27, tipo:'avance'},
  27: {destino:36, tipo:'avance'},
  36: {destino:49, tipo:'avance'},
  48: {destino:40, tipo:'retroceso'},
  51: {destino:0, tipo:'gozer'}
};
const casillasSegurasFantasma = [0,2,11,19,23,27,32,36,49];


let jugadores = [];        // lista de objetos { id, ficha(element), posicion, activo, seisConsecutivos, haPasado20 }
let ordenJugadores = [];   // array de ids en orden de juego
let turnoActual = 0;
let llegados = [];         // ids en orden de llegada
let mensajeTimer = null; // Para limpiar el temporizador del mensaje

/* Drag vertical */
let isDragging = false, startY = 0, currentTop = 0;
const gameContainer = document.getElementById("game-container");
const viewport = document.getElementById("viewport");
const board = document.getElementById("board");
const startMenuDiv = document.getElementById("startMenu");
const menuDiv = document.getElementById("menu");
const ordenSalidaDiv = document.getElementById("ordenSalida");
const textoOrdenDiv = document.getElementById("textoOrden");
const valeWrap = document.getElementById("valeWrap");
const finalModal = document.getElementById("finalModal");
const botonTirar = document.getElementById("botonTirar");
const botonMusica = document.getElementById("botonMusica");
const mensajesJuego = document.getElementById("mensajes-juego");
const dadoContenedor = document.getElementById("dado-contenedor");
const dadoElemento = document.getElementById("dado");

/* Variables de audio */
const audioMusicaInicio = document.getElementById('audio-musica-inicio');
const audioTiradaDado = document.getElementById('audio-tirada');
const audioSubida1 = document.getElementById('audio-subida-1');
const audioSubida2 = document.getElementById('audio-subida-2');
const audioBajada1 = document.getElementById('audio-bajada-1');
const audioBajada2 = document.getElementById('audio-bajada-2');
const audioGozer = document.getElementById('audio-gozer');
const audioDado6 = document.getElementById('audio-dado-6');
const audioLlegadaMeta = document.getElementById('audio-llegada-meta');
const audioFantasma = document.getElementById('audio-fantasma');
const audioPerro = document.getElementById('audio-perro');

// Nuevo: Estado de la música, se inicializa con lo guardado en localStorage o a true por defecto
let isMusicEnabled = localStorage.getItem('musicEnabled') === 'false' ? false : true;

// Nuevas variables para el modo de un solo jugador
let isSinglePlayerMode = false;
let vidasRestantes = 3;
let timerInterval = null;
let tiempoInicio = 0;
const tiempoContenedor = document.getElementById('tiempo-contenedor');
const vidasContenedor = document.getElementById('vidas-contenedor');
const tiempoRecordSpan = document.getElementById('tiempo-record');

// Variables del Fantasma
let fantasmaInterval = null;
let fantasma = null; // Variable para la instancia del fantasma

// NUEVO: Variables para el Perro del Infierno
let perroInfierno = null;
let turnosJugadorCompletados = 0; // El perro se mueve cada 4 turnos de jugador
let jugadoresHanTiradoEnRonda = 0; // NUEVA VARIABLE para la lógica de la primera ronda
// NUEVO: Bandera para saber si ya todos los jugadores humanos han tenido un turno
let todosHanTiradoPrimeraRonda = false;

function playSound(audioElement) {
    if (audioElement) {
        audioElement.currentTime = 0; // Reiniciar el audio si ya está en reproducción
        audioElement.play().catch(e => console.error("Error al reproducir audio:", e));
    }
}

function playRandomSound(audioElements) {
    const randomIndex = Math.floor(Math.random() * audioElements.length);
    playSound(audioElements[randomIndex]);
}

/* ------------ Drag vertical (solo eje Y) ------------- */
viewport.addEventListener('mousedown', (e)=>{ isDragging = true; startY = e.clientY; viewport.style.cursor = 'grabbing'; });
viewport.addEventListener('mouseup', ()=>{ isDragging = false; viewport.style.cursor = 'grab'; });
viewport.addEventListener('mouseleave', ()=>{ isDragging = false; viewport.style.cursor = 'grab'; });
viewport.addEventListener('mousemove', (e)=>{
  if (!isDragging) return;
  const dy = e.clientY - startY;
  startY = e.clientY;
  currentTop += dy;
  clampAndApplyTop();
});

function clampAndApplyTop(){
  const b = document.getElementById('board');
  const maxTop = 0;
  const minTop = viewport.clientHeight - b.clientHeight;
  if (minTop > 0) { // tablero más pequeño que viewport verticalmente
    currentTop = 0;
  } else {
    currentTop = Math.min(maxTop, Math.max(minTop, currentTop));
  }
  gameContainer.style.top = currentTop + 'px';
}

/* NUEVA FUNCION: Iniciar la musica y mostrar el menu */
function iniciarMenuJuego() {
  if (isMusicEnabled) {
    // MODIFICACIÓN: Ajuste del volumen al 10%
    audioMusicaInicio.volume = 0.1;
    playSound(audioMusicaInicio);
  }
  startMenuDiv.style.display = 'none';
  menuDiv.style.display = 'block';
  // El tiempo y el récord se muestran solo en el modo de 1 jugador
}

// Nuevo: Funcion para alternar la musica
function toggleMusica() {
    isMusicEnabled = !isMusicEnabled;
    localStorage.setItem('musicEnabled', isMusicEnabled);
    if (isMusicEnabled) {
        botonMusica.innerHTML = '&#128266;'; // Icono de altavoz ON
        playSound(audioMusicaInicio);
    } else {
        botonMusica.innerHTML = '&#128263;'; // Icono de altavoz OFF
        audioMusicaInicio.pause();
    }
}

/* ------------ Orden inicial con desempates robustos -------------- */
function prepararOrden(num){
  menuDiv.style.display = 'none';
  ordenSalidaDiv.style.display = 'block';
  valeWrap.style.display = 'none';
  textoOrdenDiv.innerHTML = '<div>Calculating rolls...</div>';
  
  isSinglePlayerMode = (num === 1);

  const initial = [];
  for(let i=0;i<num;i++){
    initial.push({ jugador: i, resultado: lanzarDado() });
  }
  procesarResultsIterativo(initial);
}

function procesarResultsIterativo(results){
  let html = '<h3>Results</h3>';
  results.forEach(r=>{
    html += `<div class="jugador-turno" style="color:${colores[r.jugador]}">Player ${nombresColores[colores[r.jugador]]}: ${r.resultado}</div>`;
  });

  const map = {};
  results.forEach(r => {
    if (!map[r.resultado]) map[r.resultado] = [];
    map[r.resultado].push(r.jugador);
  });

  const duplicatesGroups = Object.values(map).filter(g => g.length > 1);

  if (duplicatesGroups.length === 0) {
    const finalOrder = [...results].sort((a,b)=>b.resultado - a.resultado).map(r=>r.jugador);
    ordenJugadores = finalOrder.slice();
    html += `<hr><strong>Starting order:</strong><div>${ordenJugadores.map(i=>`Player ${nombresColores[colores[i]]}`).join(' → ')}</div>`;
    textoOrdenDiv.innerHTML = html;
    valeWrap.style.display = 'flex';
    return;
  }

  html += `<p><strong>Ties detected:</strong></p>`;
  duplicatesGroups.forEach(g => {
    html += `<div>Tie between: ${g.map(i=>`${nombresColores[colores[i]]}`).join(', ')}</div>`;
  });

  textoOrdenDiv.innerHTML = html;

  setTimeout(()=>{
    const newResults = results.map(r => {
      const inDup = duplicatesGroups.some(g => g.includes(r.jugador));
      if (inDup) {
        return { jugador: r.jugador, resultado: lanzarDado() };
      } else {
        return r;
      }
    });
    procesarResultsIterativo(newResults);
  }, 1200);
}

function lanzarDado(){ return Math.floor(Math.random()*6)+1; }
function lanzarDadoPerro(){ return Math.floor(Math.random()*5)+1; } // Dado de 1-5 para el perro

function confirmarOrden(){
  if (!ordenJugadores || ordenJugadores.length===0) return;
  document.getElementById('ordenSalida').style.display = 'none';
  menuDiv.style.display = 'none';
  iniciarJuego(ordenJugadores);
}

/* --------------- Iniciar juego --------------- */
function iniciarJuego(orden){
  ordenJugadores = orden.slice();
  botonTirar.style.display = 'block';
  botonTirar.disabled = false; // Habilitar el botón de tirar dado
  botonMusica.disabled = false; // Habilitar el botón de música
  mensajesJuego.style.display = 'block';
  if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
  
  jugadores = [];
  const contenedor = document.getElementById('game-container');
  contenedor.querySelectorAll('.ficha').forEach(n => n.remove());
  contenedor.querySelectorAll('.perro-infierno').forEach(n => n.remove());
  
  ordenJugadores.forEach(id => {
    const el = document.createElement('div');
    el.className = 'ficha';
    el.style.background = colores[id];
    el.dataset.id = id;
    contenedor.appendChild(el);
    jugadores.push({ id:id, ficha:el, posicion:0, activo:true, seisConsecutivos: 0, haTiradoRonda: false }); // Inicializar contador de 6s
  });
  
  // NUEVO: Añadir el perro como una entidad separada, pero oculta
  const perroEl = document.createElement('div');
  perroEl.className = 'perro-infierno';
  perroEl.dataset.id = 'perro';
  perroEl.style.opacity = 0; // Oculto por defecto
  contenedor.appendChild(perroEl);
  perroInfierno = { id: 'perro', ficha: perroEl, posicion: 0, activo: false }; // Posición 0 inicialmente
  
  llegados = [];
  turnoActual = 0;
  turnosJugadorCompletados = 0;
  jugadoresHanTiradoEnRonda = 0;
  todosHanTiradoPrimeraRonda = false;
  
  // Centrar la vista en la casilla inicial al comenzar
  centrarVistaEnPosicion(0);
  
  // Limpiar cualquier fantasma de la partida anterior
  if (fantasma) fantasma.element.remove();
  fantasma = null;
  
  colocarFichas();
  
  if (isSinglePlayerMode) {
      vidasRestantes = 3;
      actualizarVidas();
      vidasContenedor.style.display = 'flex';
      tiempoContenedor.style.display = 'block';
      tiempoRecordSpan.style.display = 'block';
      mostrarRecordTiempo();
      iniciarContador();
      iniciarFantasma();
  } else {
      vidasContenedor.style.display = 'none';
      tiempoContenedor.style.display = 'none';
      tiempoRecordSpan.style.display = 'none';
      tiempoRecordSpan.textContent = '';
  }

  // NUEVO: Llamar a la función para empezar el primer turno
  empezarTurno();
}

function empezarTurno(){
    const jugadorActual = jugadores.find(j => j.id === ordenJugadores[turnoActual]);
    if (!jugadorActual || !jugadorActual.activo) {
        determinarSiguienteTurno();
        return;
    }
    
    botonTirar.disabled = true;
    botonMusica.disabled = true;

    // NUEVO: Mover la cámara a la posición del jugador actual
    centrarVistaEnPosicion(jugadorActual.posicion);

    setTimeout(() => {
        mostrarMensaje(`Player ${nombresColores[colores[jugadorActual.id]]}'s turn`, false, colores[jugadorActual.id]);
        botonTirar.disabled = false;
        botonMusica.disabled = false;
    }, 700); // Esperar a que la transición de la cámara termine
}


// NUEVO: Funciones para el contador de tiempo
function iniciarContador() {
    tiempoInicio = Date.now();
    timerInterval = setInterval(actualizarContador, 1000);
}
function actualizarContador() {
    const tiempoTranscurrido = Date.now() - tiempoInicio;
    const segundos = Math.floor(tiempoTranscurrido / 1000);
    const minutos = Math.floor(segundos / 60);
    const segundosRestantes = segundos % 60;
    const formattedTime = `${String(minutos).padStart(2, '0')}:${String(segundosRestantes).padStart(2, '0')}`;
    tiempoContenedor.textContent = formattedTime;
}
function detenerContador() {
    clearInterval(timerInterval);
}
function mostrarRecordTiempo() {
    const tiempoRecordActual = localStorage.getItem('tiempoRecord');
    if (tiempoRecordActual) {
        const segundos = Math.floor(tiempoRecordActual / 1000);
        const minutos = Math.floor(segundos / 60);
        const segundosRestantes = segundos % 60;
        const formattedTime = `${String(minutos).padStart(2, '0')}:${String(segundosRestantes).padStart(2, '0')}`;
        tiempoRecordSpan.textContent = `Your best time: ${formattedTime}`;
    } else {
        tiempoRecordSpan.textContent = 'Your best time: --:--';
    }
}

// NUEVO: Funciones para el contador de vidas
function actualizarVidas() {
    const vidas = [document.getElementById('vida1'), document.getElementById('vida2'), document.getElementById('vida3')];
    // Asegúrate de que las imágenes 'corazon.png', 'medio_corazon.png' y 'corazon_vacio.png'
    // existen en la carpeta img/ para que los iconos se muestren correctamente.
    for(let i=0; i<3; i++) {
        if (vidasRestantes >= i + 1) {
            vidas[i].className = 'vida-icono vida-llena';
        } else if (vidasRestantes > i) {
            vidas[i].className = 'vida-icono vida-mitad';
        } else {
            vidas[i].className = 'vida-icono vida-vacia';
        }
    }
}

function manejarPerdidaVida(cantidad){
    vidasRestantes -= cantidad;
    actualizarVidas();
    if (vidasRestantes <= 0) {
        vidasRestantes = 0;
        finalizarJuegoPorVidas();
    }
}

// NUEVO: Funciones para el fantasma
function iniciarFantasma() {
    if (fantasmaInterval) clearInterval(fantasmaInterval);
    fantasmaInterval = setInterval(crearFantasma, 5000); // Intenta crear un fantasma cada 5 segundos
    
    // Si ya hay un fantasma de la partida anterior, lo eliminamos
    const oldFantasma = document.querySelector('.fantasma');
    if (oldFantasma) oldFantasma.remove();
}

function crearFantasma() {
    if (document.querySelector('.fantasma')) return; // No crear un nuevo fantasma si ya hay uno
    if (Math.random() > 0.6) { // 40% de probabilidad de que aparezca
        const nuevaFila = Math.floor(Math.random() * 5); // 5 filas en el tablero
        const direction = Math.random() < 0.5 ? 1 : -1; // 1 para derecha, -1 para izquierda
        const fantasmaEl = document.createElement('div');
        fantasmaEl.className = 'fantasma';
        fantasmaEl.style.left = direction === 1 ? '-100px' : 'calc(100% + 100px)';
        
        const scale = board.clientWidth / diseñoOriginal.width;
        let yBase = 0;
        if (nuevaFila === 0) yBase = coords[4][1];
        else if (nuevaFila === 1) yBase = coords[14][1];
        else if (nuevaFila === 2) yBase = coords[24][1];
        else if (nuevaFila === 3) yBase = coords[34][1];
        else if (nuevaFila === 4) yBase = coords[44][1];
        
        fantasmaEl.style.top = `${yBase * scale}px`;
        gameContainer.appendChild(fantasmaEl);

        fantasma = {
            element: fantasmaEl,
            direction: direction,
            x: direction === 1 ? -100 : viewport.clientWidth + 100,
            y: yBase * scale,
            speed: 5,
            isPaused: false,
            isCollisionHandled: false // NUEVO: Bandera para evitar colisiones repetidas
        };

        fantasmaEl.style.opacity = 1;
        animarFantasma();
    }
}

function animarFantasma() {
    if (!fantasma) return;
    
    const fantasmaX = parseFloat(fantasma.element.style.left);
    const fantasmaY = parseFloat(fantasma.element.style.top);
    const fantasmaWidth = fantasma.element.offsetWidth;
    
    // Si el fantasma está en pausa, no moverlo.
    if (!fantasma.isPaused) {
        // Movimiento en zigzag
        const offset = Math.sin(Date.now() / 200) * 15;
        const newX = fantasma.x + fantasma.direction * fantasma.speed;
        const newY = fantasma.y + offset;
        
        fantasma.x = newX;
        fantasma.y = newY;
    
        fantasma.element.style.left = `${newX}px`;
        fantasma.element.style.top = `${newY}px`;
    }
    
    // Colisión
    const jugador = jugadores.find(j => j.id !== 'perro' && j.activo); // El primer jugador humano
    if (jugador) {
        const ficha = jugador.ficha;
        const fichaRect = ficha.getBoundingClientRect();
        const fantasmaRect = fantasma.element.getBoundingClientRect();
    
        const isColliding = fichaRect.left < fantasmaRect.right && fichaRect.right > fantasmaRect.left && fichaRect.top < fantasmaRect.bottom && fichaRect.bottom > fantasmaRect.top;
        
        // Si hay una colisión y no se ha manejado ya para este fantasma
        if (isColliding && !fantasma.isCollisionHandled) {
            fantasma.isCollisionHandled = true; // Marcar la colisión como manejada
            if (casillasSegurasFantasma.includes(jugador.posicion)) {
                fantasma.isPaused = true;
                mostrarTextoEspecial('You are protected from the ghost!', colores[jugador.id], 1500);
                setTimeout(() => {
                    fantasma.isPaused = false;
                    // Mover el fantasma ligeramente para "romper" la colisión
                    fantasma.x += fantasma.direction * 30; 
                    animarFantasma(); // Reanudar la animación manualmente
                }, 2000);
                // No hay return aquí, ya que el requestAnimationFrame se llama al final
            } else {
                // Colisión normal
                manejarColisionFantasma(jugador);
            }
        }
    }
    
    // Remover fantasma si se sale de la pantalla
    const screenWidth = viewport.clientWidth;
    if (fantasma.x < -fantasmaWidth || fantasma.x > screenWidth) {
        fantasma.element.remove();
        fantasma = null;
        return;
    }
    
    requestAnimationFrame(animarFantasma);
}

function manejarColisionFantasma(jugador) {
    if (!fantasma) return;
    
    // Centrar la vista en la colisión antes de la animación
    centrarSiEsNecesario(jugador);
    
    // Iniciar sonido y animación
    playSound(audioFantasma);
    fantasma.element.classList.add('fantasma-colision');
    
    // Esperar a que el fantasma desaparezca antes de aplicar la lógica de juego
    setTimeout(()=>{
        mostrarTextoEspecial('A ghost has hit you!', colores[jugador.id], 2500);
        manejarPerdidaVida(0.5);
        if (fantasma) fantasma.element.remove();
        fantasma = null;
    }, 700);
}

// Nueva función unificada para manejar la colisión del perro con los jugadores
function manejarColisionPerroConJugadores(jugadoresAfectados) {
    if (jugadoresAfectados.length > 0) {
        playSound(audioPerro);
        let texto = '';
        let color = '';

        if (jugadoresAfectados.length === 1) {
            const jugadorColision = jugadoresAfectados[0];
            texto = `Player ${nombresColores[colores[jugadorColision.id]]} has collided with the Hell Hound! Go back 5 spaces.`;
            color = colores[jugadorColision.id];
        } else {
            const nombres = jugadoresAfectados.map(j => nombresColores[colores[j.id]]).join(', ');
            texto = `The Hell Hound has hit ${nombres}! Go back 5 spaces.`;
            color = 'gold';
        }
        
        mostrarTextoEspecial(texto, color, 2500);

        let retrocedidosCount = 0;
        function retrocederSiguienteJugador() {
            if (retrocedidosCount < jugadoresAfectados.length) {
                const jugadorAfectado = jugadoresAfectados[retrocedidosCount];
                let nuevaPos = Math.max(0, jugadorAfectado.posicion - 5);
                
                animarMovimiento(jugadorAfectado, nuevaPos, () => {
                    jugadorAfectado.posicion = nuevaPos;
                    colocarFichas();
                    retrocedidosCount++;
                    retrocederSiguienteJugador();
                });
            } else {
                determinarSiguienteTurno(); // El perro ha terminado su turno
            }
        }
        retrocederSiguienteJugador();

    } else {
        determinarSiguienteTurno();
    }
}


/* --------------- colocar fichas (muestra todas incluidas las llegadas) --------------- */
function colocarFichas(){
  const img = document.getElementById('board');
  const scale = img.clientWidth / diseñoOriginal.width;
  const ocupadas = {};
  
  // Recopilar jugadores activos
  jugadores.forEach(j => {
    if (j.activo) {
      const key = `c${j.posicion}`;
      if (!ocupadas[key]) ocupadas[key] = [];
      ocupadas[key].push(j);
    }
  });

  // Si el perro está activo, lo añadimos a la lista
  if (perroInfierno && perroInfierno.activo) {
      const key = `c${perroInfierno.posicion}`;
      if (!ocupadas[key]) ocupadas[key] = [];
      ocupadas[key].push(perroInfierno);
  }

  for (const key in ocupadas){
    const grupo = ocupadas[key];
    const pos = parseInt(key.slice(1));
    const [xBase,yBase] = coords[pos];
    grupo.forEach((jugador,i)=>{
      const x = (xBase * scale);
      const y = (yBase * scale);
      const offsetAngle = (i % 4);
      const dx = ((offsetAngle === 0 || offsetAngle === 3) ? -12 : 12) + (Math.floor(i/4)*6);
      const dy = ((offsetAngle === 0 || offsetAngle === 1) ? -12 : 12) + (Math.floor(i/4)*6);
      
      const offsetX = jugador.id === 'perro' ? 0 : dx;
      const offsetY = jugador.id === 'perro' ? 0 : dy;
      
      jugador.ficha.style.left = `${x}px`;
      jugador.ficha.style.top  = `${y}px`;
      jugador.ficha.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;
    });
  }
}

/* --------------- Mensajes temporales --------------- */
function mostrarMensaje(texto, temporal = true, color = '#fff') {
    if (mensajeTimer) clearTimeout(mensajeTimer);
    mensajesJuego.innerHTML = texto;
    mensajesJuego.style.opacity = 1;
    mensajesJuego.style.color = color;
    if (temporal) {
        mensajeTimer = setTimeout(() => {
            mensajesJuego.style.opacity = 0;
        }, 4000);
    }
}

/* NUEVO: Función para mostrar texto de acción especial */
function mostrarTextoEspecial(texto, color = 'gold', duracion = 2500) {
    const contenedor = document.getElementById('viewport');
    const textoEl = document.createElement('div');
    textoEl.className = 'texto-especial';
    textoEl.textContent = texto;
    textoEl.style.color = color;
    contenedor.appendChild(textoEl);
    
    setTimeout(() => {
        textoEl.remove();
    }, duracion);
}

/* --------------- movimiento: tirar dado y reglas --------------- */
function simularTirada(){
  clearTimeout(mensajeTimer);
  mensajesJuego.style.opacity = 0;
  
  const jugador = jugadores.find(j => j.id === ordenJugadores[turnoActual]);
  if (!jugador || !jugador.activo) {
    determinarSiguienteTurno();
    return;
  }
  
  // Lógica para el turno normal del jugador
  botonTirar.classList.add('animando');
  botonTirar.disabled = true;
  botonMusica.disabled = true;
  
  const colorJugador = colores[jugador.id];
  const nombreJugador = nombresColores[colores[jugador.id]];

  centrarSiEsNecesario(jugador);
  
  setTimeout(() => {
      botonTirar.classList.remove('animando');
      playSound(audioTiradaDado);
      dadoContenedor.style.display = 'block';
      dadoElemento.classList.remove('girando-final-1', 'girando-final-2', 'girando-final-3', 'girando-final-4', 'girando-final-5', 'girando-final-6');
      dadoElemento.className = 'dado girando';
      
      setTimeout(() => {
          const avance = lanzarDado();
          const posInicial = jugador.posicion;
          let posNueva = posInicial + avance;
          
          let esSeis = (avance === 6);
          let esMeta = (posNueva >= 52);
  
          dadoElemento.classList.remove('girando');
          dadoElemento.classList.add(`girando-final-${avance}`);
          
          setTimeout(() => {
              dadoContenedor.style.display = 'none';

              if (esSeis) {
                  playSound(audioDado6);
                  jugador.seisConsecutivos++;
                  let mensajeDado = '';
                  if (jugador.seisConsecutivos === 1 || jugador.seisConsecutivos === 2) {
                      mensajeDado = `Player ${nombreJugador} rolled a 6, roll again!`;
                      mostrarTextoEspecial(mensajeDado, colorJugador, 2500);
                  } else if (jugador.seisConsecutivos === 3) {
                      mensajeDado = `Player ${nombreJugador} has been toasted, back to the start!`;
                      posNueva = 0;
                      jugador.seisConsecutivos = 0;
                      esSeis = false; // El turno termina después de 3 seises
                  }
                  mostrarTextoEspecial(mensajeDado, colorJugador, 2500);
              } else {
                  jugador.seisConsecutivos = 0;
                  mostrarMensaje(`Player ${nombreJugador} rolled a ${avance}.`, true, colorJugador);
              }
              
              animarMovimiento(jugador, esMeta ? 52 : posNueva, () => {
                  if (isSinglePlayerMode && esMeta) {
                      jugador.posicion = 52;
                      llegados.push(jugador.id);
                      jugador.activo = false;
                      jugador.ficha.classList.add('ficha-levantada');
                      mostrarMensaje(`Player ${nombreJugador} has reached the finish line!`, false, colorJugador);
                      playSound(audioLlegadaMeta);
                      
                      finalizarJuegoPorVictoria();

                  } else if (esMeta) {
                      jugador.posicion = 52;
                      llegados.push(jugador.id);
                      jugador.activo = false;
                      jugador.ficha.classList.add('ficha-levantada');
                      mostrarMensaje(`Player ${nombreJugador} has reached the finish line!`, false, colorJugador);
                      playSound(audioLlegadaMeta);
                      
                      // NUEVA LÓGICA: Si llega a la meta, no vuelve a tirar. Se acaba su turno.
                      determinarSiguienteTurno();
                  } else {
                      jugador.posicion = posNueva;
                      // Cuando la ficha aterriza en la casilla 0 por los 3 seises, no se queda levantada.
                      if(jugador.posicion === 0 && !esSeis) { 
                          jugador.ficha.classList.remove('ficha-levantada');
                      }
                      manejarFinDeTurno(jugador, esSeis);
                  }
              });
          }, 2000);
      }, 1000);
  }, 700);
}

function manejarFinDeTurno(jugador, esSeis) {
    
    // Primero comprobamos si hay colisión con el perro
    if (perroInfierno.activo && jugador.posicion === perroInfierno.posicion) {
        // CORRECCIÓN: La colisión con el perro ahora se maneja después de resolver la casilla especial.
        // Pero en este punto, el jugador ya ha movido. La lógica de retroceso de 5 se hace en el callback.
        // La animación de movimiento ya se ha completado, por lo que llamamos a la función de colisión.
        manejarColisionPerroConJugadores([jugador]);
    } else {
        // Después, comprobamos si hay una casilla especial
        const casillaEspecial = especiales[jugador.posicion];
        if (casillaEspecial) {
            manejarCasillaEspecial(jugador, esSeis);
        } else {
            // Si no hay casilla especial, revisamos si se sacó un 6
            if (esSeis && jugador.seisConsecutivos <= 2) {
                mostrarMensaje(`Player ${nombresColores[colores[jugador.id]]} roll again!`, false, colores[jugador.id]);
                botonTirar.disabled = false;
                botonMusica.disabled = false;
            } else {
                determinarSiguienteTurno();
            }
        }
    }
}


// Lógica de movimiento del perro del infierno
function moverPerroDelInfierno() {
    const perro = perroInfierno;
    mostrarMensaje('Hell Hound\'s turn!', false, 'red');
    
    botonTirar.disabled = true;
    botonMusica.disabled = true;
    
    // Tirada de dado especial para el perro (1-5)
    const avance = lanzarDadoPerro();
    let posNueva = perro.posicion + avance;
    
    // Si el perro llega o supera la casilla 52, vuelve a 1
    if (posNueva >= 52) {
        posNueva = 1;
        mostrarTextoEspecial('The Hell Hound has returned to the starting space!', 'red', 2500);
    }
    
    // Si el perro no estaba activo, lo hacemos visible y lo movemos a la casilla 1
    if (!perro.activo) {
        perro.activo = true;
        posNueva = 1; // La primera vez siempre va a la 1
        perro.ficha.style.opacity = 1;
        mostrarTextoEspecial('The Hell Hound has appeared!', 'red', 2500);
    }

    animarMovimiento(perro, posNueva, () => {
        perro.posicion = posNueva;
        colocarFichas();
        
        // CORRECCIÓN: el perro no tiene efecto en casillas especiales, solo con los jugadores
        const jugadoresAfectados = jugadores.filter(j => j.id !== 'perro' && j.activo && j.posicion === perro.posicion);
        manejarColisionPerroConJugadores(jugadoresAfectados);
    });
}

function animarMovimiento(jugador, posDestino, callback){
  const posInicial = jugador.posicion;
  const paso = posInicial < posDestino ? 1 : -1;
  const esEspecial = especiales[posDestino];
  
  // NUEVO: La ficha se levanta al inicio del movimiento.
  if (jugador.id !== 'perro') {
      jugador.ficha.classList.add('ficha-levantada');
  }

  if (posInicial === posDestino) {
    if (jugador.id !== 'perro') {
      jugador.ficha.classList.remove('ficha-levantada');
    }
    if (callback) callback();
    return;
  }
  
  const timer = setInterval(()=>{
    const nuevaPos = jugador.posicion + paso;
    jugador.posicion = nuevaPos;
    colocarFichas();
    
    centrarVistaEnPosicion(jugador.posicion);

    // CORRECCIÓN: Solo los jugadores humanos emiten el sonido de las casillas especiales
    if (jugador.id !== 'perro') {
        if (esEspecial && (esEspecial.tipo === 'avance' || esEspecial.tipo === 'retroceso')) {
            if (paso === 1) playRandomSound([audioSubida1, audioSubida2]);
            else playRandomSound([audioBajada1, audioBajada2]);
        }
    }

    if (nuevaPos === posDestino){
      clearInterval(timer);
      if (jugador.id !== 'perro') {
          jugador.ficha.classList.remove('ficha-levantada');
      }
      if (callback) callback();
    }
  }, 100);
}

/* --------------- reglas de casillas especiales --------------- */
function manejarCasillaEspecial(jugador, esSeis) {
    const nombreJugador = nombresColores[colores[jugador.id]];
    const colorJugador = colores[jugador.id];
    const casillaEspecial = especiales[jugador.posicion];
    if (!casillaEspecial) {
        // NUEVA LÓGICA: Si no hay casilla especial, continuamos con la lógica del 6
        if (isSinglePlayerMode) {
             // En modo 1 jugador, no hay "siguiente turno" si no sacas 6
            if (esSeis && jugador.seisConsecutivos <= 2) {
                mostrarMensaje(`Player ${nombresColores[colores[jugador.id]]} roll again!`, false, colores[jugador.id]);
                botonTirar.disabled = false;
                botonMusica.disabled = false;
            } else {
                 // Si no es un 6, simplemente el turno termina y esperamos al jugador
                mostrarMensaje(`End of turn. Roll the dice to continue.`, false, colores[jugador.id]);
                // Volver a habilitar el botón
                botonTirar.disabled = false;
                botonMusica.disabled = false;
            }
        } else if (esSeis && jugador.seisConsecutivos <= 2) {
            mostrarMensaje(`Player ${nombresColores[colores[jugador.id]]} roll again!`, false, colores[jugador.id]);
            botonTirar.disabled = false;
            botonMusica.disabled = false;
        } else {
            determinarSiguienteTurno();
        }
        return;
    }

    let texto = '';
    let playSoundGozer = false;
    let tieneEfectoAdicional = false;

    if (casillaEspecial.tipo === 'avance') {
        texto = `Great! Player ${nombreJugador} advances to space ${casillaEspecial.destino}!`;
    } else if (casillaEspecial.tipo === 'retroceso') {
        texto = `Oh no! Player ${nombreJugador} goes back to space ${casillaEspecial.destino}.`;
    } else if (casillaEspecial.tipo === 'gozer') {
        texto = `Player ${nombreJugador} meets Gozer! Returns to the starting space.`;
        playSoundGozer = true;
        tieneEfectoAdicional = true; // Efecto de perder vida
    }
    
    centrarSiEsNecesario(jugador);
    //jugador.ficha.classList.add('ficha-levantada'); // Se levanta en la animación
    
    setTimeout(() => {
        mostrarTextoEspecial(texto, colorJugador, 2500);
        
        const resplandor = document.createElement('div');
        resplandor.className = 'casilla-resplandor ' + (casillaEspecial.tipo === 'avance' ? 'brillo-verde' : (casillaEspecial.tipo === 'gozer' ? 'brillo-gozer' : 'brillo-rojo'));
        gameContainer.appendChild(resplandor);
        const [xBase, yBase] = coords[jugador.posicion];
        const scale = board.clientWidth / diseñoOriginal.width;
        resplandor.style.left = `${xBase * scale}px`;
        resplandor.style.top = `${yBase * scale}px`;

        if(playSoundGozer) playSound(audioGozer);
        
        setTimeout(()=>{
          resplandor.remove();
          animarMovimiento(jugador, casillaEspecial.destino, ()=>{
            jugador.posicion = casillaEspecial.destino;
            colocarFichas();
            //jugador.ficha.classList.remove('ficha-levantada'); // Se baja en la animación
            
            if (tieneEfectoAdicional && isSinglePlayerMode) {
                manejarPerdidaVida(1);
            }
            
            centrarVistaEnPosicion(jugador.posicion);

            setTimeout(() => {
                const nuevaCasillaEspecial = especiales[jugador.posicion];
                if (nuevaCasillaEspecial && (nuevaCasillaEspecial.tipo === 'avance' || nuevaCasillaEspecial.tipo === 'retroceso')) {
                  mostrarMensaje(`Player ${nombreJugador} is saved from the new space's effect.`, false, colorJugador);
                }
                
                // NUEVA LÓGICA: Después de resolver la casilla especial, si se sacó un 6, se permite volver a tirar.
                if (isSinglePlayerMode) {
                    if (esSeis && jugador.seisConsecutivos <= 2) {
                        mostrarMensaje(`Player ${nombresColores[colores[jugador.id]]} roll again!`, false, colores[jugador.id]);
                        botonTirar.disabled = false;
                        botonMusica.disabled = false;
                    } else {
                        // Si no es un 6, el turno termina y esperamos al jugador
                        mostrarMensaje(`End of turn. Roll the dice to continue.`, false, colores[jugador.id]);
                        botonTirar.disabled = false;
                        botonMusica.disabled = false;
                    }
                } else {
                    if (esSeis && jugador.seisConsecutivos <= 2) {
                        mostrarMensaje(`Player ${nombresColores[colores[jugador.id]]} roll again!`, false, colores[jugador.id]);
                        botonTirar.disabled = false;
                        botonMusica.disabled = false;
                    } else {
                        determinarSiguienteTurno();
                    }
                }
            }, 700);
          });
        }, 2500);
    }, 1500);
}

// Función unificada para determinar el siguiente turno
function determinarSiguienteTurno() {
    // NUEVO: En modo de 1 jugador, no se cambia de turno
    if (isSinglePlayerMode) {
      setTimeout(() => {
        const jugador = jugadores.find(j => j.id !== 'perro' && j.activo);
        if (jugador) {
            // Habilitar el botón para que el jugador pueda seguir tirando
            botonTirar.disabled = false;
            botonMusica.disabled = false;
        } else {
            // Esto solo se ejecutará si el jugador perdió por vidas
            finalizarJuegoPorVidas();
        }
      }, 2000);
      return;
    }
    
    // Si no es modo 1 jugador, se aplica la lógica anterior
    setTimeout(() => {
        const jugadoresHumanosActivos = jugadores.filter(j => j.activo);
      
        if (jugadoresHumanosActivos.length <= 1) {
          mostrarFinal();
          return;
        }
        
        if (!todosHanTiradoPrimeraRonda) {
            jugadoresHanTiradoEnRonda++;
            if (jugadoresHanTiradoEnRonda >= ordenJugadores.length) {
                todosHanTiradoPrimeraRonda = true;
                moverPerroDelInfierno();
                return;
            }
        } else {
            turnosJugadorCompletados++;
        }

        if (perroInfierno.activo && turnosJugadorCompletados >= 4) {
          turnosJugadorCompletados = 0;
          moverPerroDelInfierno();
          return;
        }

        let attempts = 0;
        do {
          turnoActual = (turnoActual + 1) % ordenJugadores.length;
          attempts++;
        } while (attempts < ordenJugadores.length && !jugadores.find(j => j.id === ordenJugadores[turnoActual]).activo);
      
        const siguienteJugador = jugadores.find(j => j.id === ordenJugadores[turnoActual]);
        if (siguienteJugador) {
          empezarTurno(); // NUEVO: Llamamos a la función para iniciar el turno del siguiente jugador
        } else {
            mostrarFinal();
        }
    }, 2000); // Pausa de 2 segundos
}

function finalizarJuegoPorVidas() {
    detenerContador();
    if (fantasmaInterval) clearInterval(fantasmaInterval);
    if (fantasma) fantasma.element.remove();
    
    const jugador = jugadores.find(j => j.id !== 'perro');
    if (jugador) centrarVistaEnPosicion(jugador.posicion);
    
    botonTirar.style.display = 'none';
    mensajesJuego.style.display = 'none';
    vidasContenedor.style.display = 'none';
    tiempoContenedor.style.display = 'none';
    tiempoRecordSpan.style.display = 'none';
    dadoContenedor.style.display = 'none';

    botonMusica.disabled = false;

    finalModal.innerHTML = '<h3>Game Over!</h3><p>You ran out of lives.</p><div class="modal-buttons"><button onclick="reiniciarJuego()">Play again</button></div>';
    finalModal.style.display = 'block';
}

// Nueva función para terminar el juego cuando el jugador de 1 persona gana
function finalizarJuegoPorVictoria() {
    detenerContador();
    if (fantasmaInterval) clearInterval(fantasmaInterval);
    if (fantasma) fantasma.element.remove();

    const tiempoFinal = Date.now() - tiempoInicio;
    const segundos = Math.floor(tiempoFinal / 1000);
    const minutos = Math.floor(segundos / 60);
    const segundosRestantes = segundos % 60;
    const formattedTime = `${String(minutos).padStart(2, '0')}:${String(segundosRestantes).padStart(2, '0')}`;
    
    const tiempoRecordActual = localStorage.getItem('tiempoRecord');
    let esRecord = false;
    if (!tiempoRecordActual || tiempoFinal < parseInt(tiempoRecordActual)) {
        localStorage.setItem('tiempoRecord', tiempoFinal);
        esRecord = true;
    }
    
    let html = '<h3>Congratulations!</h3>';
    html += `<p>You reached the goal in: ${formattedTime}</p>`;
    if (esRecord) {
        html += `<p>NEW RECORD!</p>`;
    }
    html += `<div class="modal-buttons"><button onclick="reiniciarJuego()">Play again</button></div>`;
    
    finalModal.innerHTML = html;
    finalModal.style.display = 'block';
    
    botonTirar.style.display = 'none';
    mensajesJuego.style.display = 'none';
    vidasContenedor.style.display = 'none';
    tiempoContenedor.style.display = 'none';
    tiempoRecordSpan.style.display = 'none';
    dadoContenedor.style.display = 'none';
}


function mostrarFinal(){
  detenerContador();
  if (fantasmaInterval) clearInterval(fantasmaInterval);
  if (fantasma) fantasma.element.remove();
  
  if (jugadores.length > 0) {
    centrarVistaEnPosicion(52);
  }
  
  let html = '<h3>End of Game</h3>';

  const jugadoresHumanosActivos = jugadores.filter(j => j.activo && j.id !== 'perro');
  const ultimoJugador = jugadoresHumanosActivos.length > 0 ? jugadoresHumanosActivos[0] : null;

  if (isSinglePlayerMode) {
    finalizarJuegoPorVictoria();
  } else {
    // Clasificación final para múltiples jugadores
    llegados.forEach((id,i)=>{
        html+=`<p>${i+1}º: Player ${nombresColores[colores[id]]}</p>`;
    });
    if(ultimoJugador) {
        html+=`<p>${llegados.length + 1}º: Player ${nombresColores[colores[ultimoJugador.id]]} (Last on the board)</p>`;
    }
    html += '<div class="modal-buttons"><button onclick="reiniciarJuego()">Play again</button></div>';
  }
  
  finalModal.innerHTML = html;
  finalModal.style.display = 'block';

  botonTirar.style.display = 'none';
  mensajesJuego.style.display = 'none';
  dadoContenedor.style.display = 'none';

  botonMusica.disabled = false;
}

function reiniciarJuego(){
  finalModal.style.display = 'none';
  document.getElementById('ordenSalida').style.display = 'none';
  botonTirar.style.display = 'none';
  mensajesJuego.style.display = 'none';
  vidasContenedor.style.display = 'none';
  tiempoContenedor.style.display = 'none';
  tiempoRecordSpan.style.display = 'none';
  dadoContenedor.style.display = 'none';

  const contenedor = document.getElementById('game-container');
  contenedor.querySelectorAll('.ficha').forEach(n => n.remove());
  contenedor.querySelectorAll('.perro-infierno').forEach(n => n.remove());

  if (fantasma) fantasma.element.remove();
  fantasma = null;
  if (fantasmaInterval) clearInterval(fantasmaInterval);
  
  perroInfierno = null;
  
  jugadores = [];
  ordenJugadores = [];
  llegados = [];
  turnoActual = 0;
  isSinglePlayerMode = false;
  todosHanTiradoPrimeraRonda = false;
  
  menuDiv.style.display = 'block';
  startMenuDiv.style.display = 'none';
}

/* --------------- utilidades --------------- */
function centrarSiEsNecesario(jugador) {
    const fichaRect = jugador.ficha.getBoundingClientRect();
    const viewportRect = viewport.getBoundingClientRect();
    const gameContainerRect = gameContainer.getBoundingClientRect();
    
    const fichaTop = fichaRect.top - gameContainerRect.top;
    const fichaBottom = fichaRect.bottom - gameContainerRect.top;
    
    if (fichaTop < 0 || fichaBottom > viewportRect.height) {
        const offset = (viewportRect.height / 2) - fichaRect.height;
        currentTop = -(fichaTop - offset);
        clampAndApplyTop();
    }
}

function centrarVistaEnPosicion(posicion) {
    if (posicion < 0 || posicion >= coords.length) return;
    const [x, y] = coords[posicion];
    const scale = board.clientWidth / diseñoOriginal.width;
    const centerY = (y * scale);
    const viewportHeight = viewport.clientHeight;
    
    currentTop = (viewportHeight / 2) - centerY;
    clampAndApplyTop();
}

window.addEventListener('resize', () => {
  colocarFichas();
  clampAndApplyTop();
});

document.addEventListener('DOMContentLoaded', () => {
    // NUEVO: Establecer el volumen de la música al cargar la página para evitar que suene al 100%
    audioMusicaInicio.volume = 0.1;
    
    if (isMusicEnabled) {
        botonMusica.innerHTML = '&#128266;';
    } else {
        botonMusica.innerHTML = '&#128263;';
    }
    startMenuDiv.style.display = 'block';
});

document.addEventListener('keydown', (e) => {
    const jugadorActual = jugadores.find(j => j.id === ordenJugadores[turnoActual]);
    if ((e.key === ' ' || e.key === 'Enter') && !botonTirar.disabled && jugadorActual && jugadorActual.id !== 'perro') {
        simularTirada();
    }
});

// NUEVO: Manejo de teclas para resetear el récord
let keysPressed = {};
document.addEventListener('keydown', (event) => {
    keysPressed[event.key] = true;
    if (isSinglePlayerMode && keysPressed['r'] && keysPressed['b']) {
        localStorage.removeItem('tiempoRecord');
        mostrarTextoEspecial('Record deleted!', '#ff4444', 1500);
        mostrarRecordTiempo();
    }
});

document.addEventListener('keyup', (event) => {
    delete keysPressed[event.key];
});
</script>
</body>
</html>