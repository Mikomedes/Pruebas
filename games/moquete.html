<!DOCTYPE html>
<html lang="es">

<head>
<link rel="shortcut icon" href="img/favicon.ico">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>¡Ayúdanos Moquete!</title>
  <style>
    html,body{
      margin:0;padding:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Arial;
    }
    /* Viewport */
    #viewport{
      width:100vw;height:100vh;overflow:hidden;position:relative;cursor:grab;
    }
    /* Contenedor centrado horizontalmente */
    #game-container{
      position:absolute;top:0;left:50%;transform:translateX(-50%);
      /* no tamaño fijo: el <img> define el tamaño real */
      transition: top 0.5s ease-in-out; /* TRANSICIÓN PARA EL DESPLAZAMIENTO SUAVE */
    }
    #board{
      width:100vw;height:auto;display:block;user-select:none;-webkit-user-drag:none;
    }

    /* fichas */
    .ficha{
      position:absolute;
      width:1.5vw;
      aspect-ratio:1;
      border-radius:50%;
      border:2px solid #fff;
      z-index:10;
      box-sizing:border-box;
      transform:translate(-50%,-50%); /* centrar en su punto */
      transition: all 0.5s ease-in-out; /* Animación para el movimiento suave */
    }
    /* Clase para la animación de 'levantar' la ficha */
    .ficha-levantada {
        transform: translate(calc(-50% - 15px), calc(-50% - 15px)) scale(1.4);
        z-index: 20;
    }
    
    /* Contador de vidas */
    #vidas-contenedor {
      display: flex;
      gap: 5px;
      margin-top: 10px; /* Separación de los botones */
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 8px;
    }
    .vida-icono {
      width: 40px;
      height: 40px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transition: transform 0.3s ease;
    }
    .vida-llena { background-image: url('img/corazon.png'); }
    .vida-mitad { background-image: url('img/medio_corazon.png'); }
    .vida-vacia { background-image: url('img/corazon_vacio.png'); }

    /* Contador de tiempo */
    #tiempo-contenedor {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 200;
      color: gold;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(0,0,0,0.5);
      display: none; /* Se oculta por defecto y se muestra en modo 1 jugador */
    }
    #tiempo-record {
        position: fixed;
        top: 55px;
        right: 20px;
        z-index: 200;
        color: #fff;
        font-size: 16px;
        text-shadow: 0 0 5px rgba(0,0,0,0.5);
        display: none; /* Se oculta por defecto y se muestra en modo 1 jugador */
    }
    

    /* botones de control (tirar, musica) */
    .controles {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 200;
        display: flex;
        flex-direction: column; /* Cambio a vertical */
        gap: 10px;
        align-items: flex-start; /* Alineación a la izquierda */
    }
    .controles-top {
        display: flex;
        flex-direction: row;
        gap: 10px;
        align-items: center;
    }
   .boton{
      padding:12px 20px;
      background:#444;
      color:#fff;
      border:none;
      border-radius:8px;
      cursor:pointer;
      font-size:16px;
      font-weight: bold;
      transition: transform 0.3s ease, background 0.3s ease; /* para animación */
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    /* Estilos para el botón de música con icono */
    #botonMusica {
        font-size: 20px;
        padding: 10px 15px;
    }
    .boton.animando {
      transform: scale(1.1) rotate(-10deg);
    }
    .boton:disabled {
      background: #777;
      cursor: not-allowed;
      box-shadow: none;
    }
    .boton:hover:enabled {
        background: #555;
    }

    /* Mensajes y estado */
    #mensajes-juego {
      position: fixed;
      right: 20px;
      top: 100px;
      z-index: 200;
      background: #222;
      color: #fff;
      padding: 10px;
      border-radius: 6px;
      font-size: 14px;
      min-width: 200px;
      text-align: center;
      transition: opacity 0.5s ease-out, color 0.5s ease-out;
    }
    #dado-contenedor {
        position: fixed;
        right: 20px;
        top: 180px;
        width: 60px;
        height: 60px;
        z-index: 200;
        display: none;
        perspective: 1000px;
    }
    .dado {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
    }
    .dado-cara {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #fff;
        border-radius: 8px;
        font-size: 30px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #333;
        border: 2px solid #333;
    }
    .dado-cara-1 { transform: rotateY(0deg) translateZ(30px); }
    .dado-cara-2 { transform: rotateX(90deg) translateZ(30px); }
    .dado-cara-3 { transform: rotateY(90deg) translateZ(30px); }
    .dado-cara-4 { transform: rotateY(-90deg) translateZ(30px); }
    .dado-cara-5 { transform: rotateX(-90deg) translateZ(30px); }
    .dado-cara-6 { transform: rotateY(-180deg) translateZ(30px); }
    
    .girando {
        animation: dado-girando 1s infinite linear;
    }
    @keyframes dado-girando {
        0% { transform: rotateX(0) rotateY(0) rotateZ(0); }
        100% { transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg); }
    }
    .girando-final-1 { animation: girar-a-1 1s ease-out forwards; }
    .girando-final-2 { animation: girar-a-2 1s ease-out forwards; }
    .girando-final-3 { animation: girar-a-3 1s ease-out forwards; }
    .girando-final-4 { animation: girar-a-4 1s ease-out forwards; }
    .girando-final-5 { animation: girar-a-5 1s ease-out forwards; }
    .girando-final-6 { animation: girar-a-6 1s ease-out forwards; }
    
    @keyframes girar-a-1 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(0deg) rotateX(0deg);} }
    @keyframes girar-a-2 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateX(-90deg);} }
    @keyframes girar-a-3 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(-90deg);} }
    @keyframes girar-a-4 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(90deg);} }
    @keyframes girar-a-5 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateX(90deg);} }
    @keyframes girar-a-6 { from {transform: rotateX(0) rotateY(0) rotateZ(0);} to {transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) rotateY(180deg);} }

    /* modales (menu / orden / final) */
    .modal{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      background:rgba(17,17,17,0.9);
      color:#fff;padding:25px 35px;border-radius:12px;z-index:300;text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,0.8);
      min-width:280px;
    }
    .modal h3 {
        margin-top: 0;
        margin-bottom: 20px;
        color: gold;
        text-shadow: 0 0 5px rgba(255,215,0,0.5);
    }
    .modal .modal-buttons {
        margin-top: 15px;
        display: flex;
        justify-content: center;
        gap: 10px;
    }
    .modal button{
      padding:10px 20px;
      font-size:16px;
      font-weight: bold;
      cursor:pointer;
      border-radius:8px;
      border:none;
      background: linear-gradient(145deg, #444, #222);
      color: #fff;
      box-shadow: inset 0 1px 3px rgba(255,255,255,0.1), 0 5px 15px rgba(0,0,0,0.6);
      transition: all 0.2s ease;
    }
    .modal button:hover {
        background: linear-gradient(145deg, #555, #333);
        transform: translateY(-2px);
    }
    #ordenSalida .jugador-turno{margin:6px 0}
    /* animaciones */
    .brillo{animation:resplandor .5s alternate infinite;box-shadow:0 0 8px gold}
    @keyframes resplandor{from{box-shadow:0 0 8px gold}to{box-shadow:0 0 26px gold}}

    /* Nuevos resplandores para casillas */
    .casilla-resplandor {
        position: absolute;
        pointer-events: none;
        width: 3vw;
        height: 3vw;
        border-radius: 50%;
        z-index: 50;
        transform: translate(-50%,-50%);
        box-sizing: border-box;
    }
    .brillo-rojo {
        animation: resplandor-rojo 0.5s alternate infinite;
    }
    .brillo-verde {
        animation: resplandor-verde 0.5s alternate infinite;
    }
    .brillo-gozer {
        animation: resplandor-gozer 0.2s alternate infinite;
    }
    @keyframes resplandor-rojo {
        from { box-shadow: 0 0 10px 2px red; }
        to { box-shadow: 0 0 20px 8px red; }
    }
    @keyframes resplandor-verde {
        from { box-shadow: 0 0 10px 2px green; }
        to { box-shadow: 0 0 20px 8px green; }
    }
    @keyframes resplandor-gozer {
        from { box-shadow: 0 0 10px 2px #4a9fe8; }
        to { box-shadow: 0 0 30px 10px #4a9fe8; }
    }
    
    .texto-flotante{position:absolute;color:gold;font-weight:bold;pointer-events:none;text-shadow:1px 1px 4px rgba(0,0,0,0.7);z-index:400;transform:translate(-50%,-100%);animation:flotar 1.6s ease-out forwards}
    @keyframes flotar{0%{opacity:1;transform:translate(-50%,0)}100%{opacity:0;transform:translate(-50%,-50px)}}
    
    /* NUEVO: Estilos para el texto de acción especial con recuadro */
    .texto-especial {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 3vw; /* Más grande que el mensaje flotante */
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.5);
        pointer-events: none;
        z-index: 500;
        opacity: 0;
        animation: texto-accion-anim 2.5s ease-out forwards;
        background-color: rgba(0,0,0,0.7); /* Fondo semi-transparente */
        padding: 1vw 2vw; /* Relleno */
        border-radius: 1vw; /* Esquinas redondeadas */
        white-space: nowrap; /* Para que el texto no se rompa */
    }
    @keyframes texto-accion-anim {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
    }
    
    /* Fantasma */
    .fantasma {
        position: absolute;
        width: 100px;
        height: 100px;
        background-image: url('img/fantasma.gif');
        background-size: contain;
        background-repeat: no-repeat;
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.5s ease;
    }
    
    /* Animación de desaparición del fantasma */
    .fantasma-colision {
        animation: fadeOutScale 0.7s forwards;
    }
    @keyframes fadeOutScale {
        from { opacity: 1; transform: scale(1); }
        to { opacity: 0; transform: scale(1.5); }
    }
    
    /* Perro del Infierno */
    .perro-infierno {
        position: absolute;
        width: 100px;
        height: 100px;
        background-image: url('img/perro_infierno.gif');
        background-size: contain;
        background-repeat: no-repeat;
        pointer-events: none;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.5s ease;
        transform: translate(-50%, -50%);
    }


  </style>
</head>
<body>
  
  <audio id="audio-musica-inicio" src="sonidos/000.mp3" preload="auto" loop></audio>
  <audio id="audio-subida-1" src="sonidos/001.mp3" preload="auto"></audio>
  <audio id="audio-subida-2" src="sonidos/002.mp3" preload="auto"></audio>
  <audio id="audio-bajada-1" src="sonidos/003.mp3" preload="auto"></audio>
  <audio id="audio-bajada-2" src="sonidos/004.mp3" preload="auto"></audio>
  <audio id="audio-gozer" src="sonidos/005.mp3" preload="auto"></audio>
  <audio id="audio-dado-6" src="sonidos/006.mp3" preload="auto"></audio>
  <audio id="audio-llegada-meta" src="sonidos/007.mp3" preload="auto"></audio>
  <audio id="audio-tirada" src="sonidos/008.mp3" preload="auto"></audio>
  <audio id="audio-fantasma" src="sonidos/009.mp3" preload="auto"></audio>
  <audio id="audio-perro" src="sonidos/010.mp3" preload="auto"></audio>


  <div id="startMenu" class="modal">
    <h3>¡Ayúdanos Moquete!</h3>
    <div class="modal-buttons">
      <button onclick="iniciarMenuJuego()">¡Empezar a jugar!</button>
    </div>
  </div>

  <div id="menu" class="modal" style="display:none;">
    <h3>Selecciona número de jugadores</h3>
    <div class="modal-buttons">
      <button onclick="prepararOrden(1)">1 Jugador</button>
      <button onclick="prepararOrden(2)">2 Jugadores</button>
      <button onclick="prepararOrden(3)">3 Jugadores</button>
      <button onclick="prepararOrden(4)">4 Jugadores</button>
    </div>
  </div>

  <div id="ordenSalida" class="modal" style="display:none;">
    <div id="textoOrden"></div>
    <div id="valeWrap" class="modal-buttons" style="display:none;">
      <button onclick="confirmarOrden()">VALE</button>
    </div>
  </div>

  <div id="finalModal" class="modal" style="display:none;"></div>
  
  <div id="tiempo-contenedor">00:00</div>
  <div id="tiempo-record"></div>

  <div class="controles">
    <div class="controles-top">
      <button id="botonMusica" class="boton" onclick="toggleMusica()"></button>
      <button id="botonTirar" class="boton" style="display:none;" onclick="simularTirada()">Tirar dado</button>
    </div>
    <div id="vidas-contenedor" style="display:none;">
      <div class="vida-icono" id="vida1"></div>
      <div class="vida-icono" id="vida2"></div>
      <div class="vida-icono" id="vida3"></div>
    </div>
  </div>

  <div id="mensajes-juego" style="display:none;"></div>
  
  <div id="dado-contenedor">
    <div id="dado" class="dado">
      <div class="dado-cara dado-cara-1">1</div>
      <div class="dado-cara dado-cara-2">2</div>
      <div class="dado-cara dado-cara-3">3</div>
      <div class="dado-cara dado-cara-4">4</div>
      <div class="dado-cara dado-cara-5">5</div>
      <div class="dado-cara dado-cara-6">6</div>
    </div>
  </div>

  <div id="viewport">
    <div id="game-container">
      <img id="board" src="img/tablero.png" alt="Tablero">
    </div>
  </div>

<script>
/* --------- Datos y estado ---------- */
const diseñoOriginal = { width: 5315, height: 3780 };
const colores = ["#e84a4a","#4a9fe8","#4ae89f","#e8d14a"]; // rojo, azul, verde, amarillo
const nombresColores = {
  "#e84a4a": "Rojo",
  "#4a9fe8": "Azul",
  "#4ae89f": "Verde",
  "#e8d14a": "Amarillo"
};
const coords = [
  [630,3413],[618,2884],[672,2566],[870,2313],[1165,2229],[1441,2355],[1669,2590],[1885,2860],[2070,3100],[2324,3317],
  [2630,3417],[2936,3359],[3213,3191],[3345,2890],[3291,2572],[3080,2325],[2810,2151],[2522,2055],[2216,1983],[1899,1899],
  [1580,1832],[1273,1790],[954,1700],[660,1532],[504,1280],[450,973],[546,667],[764,431],[1069,312],[1387,300],
  [1705,348],[2005,426],[2294,552],[2576,739],[2816,931],[3026,1183],[3201,1442],[3375,1730],[3513,2019],[3651,2295],
  [3783,2584],[3927,2884],[4101,3151],[4348,3353],[4660,3370],[4936,3220],[5050,2914],[5008,2608],[4882,2301],[4690,2025],
  [4492,1790],[4258,1586],[3879,1280]
];
const especiales = {
  2: {destino:23, tipo:'avance'},
  19: {destino:32, tipo:'avance'},
  18: {destino:6, tipo:'retroceso'},
  11: {destino:27, tipo:'avance'},
  27: {destino:36, tipo:'avance'},
  36: {destino:49, tipo:'avance'},
  48: {destino:40, tipo:'retroceso'},
  51: {destino:0, tipo:'gozer'}
};
const casillasSegurasFantasma = [0,2,11,19,23,27,32,36,49];


let jugadores = [];        // lista de objetos { id, ficha(element), posicion, activo, seisConsecutivos, haPasado20 }
let ordenJugadores = [];   // array de ids en orden de juego
let turnoActual = 0;
let llegados = [];         // ids en orden de llegada
let mensajeTimer = null; // Para limpiar el temporizador del mensaje

/* Drag vertical */
let isDragging = false, startY = 0, currentTop = 0;
const gameContainer = document.getElementById("game-container");
const viewport = document.getElementById("viewport");
const board = document.getElementById("board");
const startMenuDiv = document.getElementById("startMenu");
const menuDiv = document.getElementById("menu");
const ordenSalidaDiv = document.getElementById("ordenSalida");
const textoOrdenDiv = document.getElementById("textoOrden");
const valeWrap = document.getElementById("valeWrap");
const finalModal = document.getElementById("finalModal");
const botonTirar = document.getElementById("botonTirar");
const botonMusica = document.getElementById("botonMusica");
const mensajesJuego = document.getElementById("mensajes-juego");
const dadoContenedor = document.getElementById("dado-contenedor");
const dadoElemento = document.getElementById("dado");

/* Variables de audio */
const audioMusicaInicio = document.getElementById('audio-musica-inicio');
const audioTiradaDado = document.getElementById('audio-tirada');
const audioSubida1 = document.getElementById('audio-subida-1');
const audioSubida2 = document.getElementById('audio-subida-2');
const audioBajada1 = document.getElementById('audio-bajada-1');
const audioBajada2 = document.getElementById('audio-bajada-2');
const audioGozer = document.getElementById('audio-gozer');
const audioDado6 = document.getElementById('audio-dado-6');
const audioLlegadaMeta = document.getElementById('audio-llegada-meta');
const audioFantasma = document.getElementById('audio-fantasma');
const audioPerro = document.getElementById('audio-perro');

// Nuevo: Estado de la música, se inicializa con lo guardado en localStorage o a true por defecto
let isMusicEnabled = localStorage.getItem('musicEnabled') === 'false' ? false : true;

// Nuevas variables para el modo de un solo jugador
let isSinglePlayerMode = false;
let vidasRestantes = 3;
let timerInterval = null;
let tiempoInicio = 0;
const tiempoContenedor = document.getElementById('tiempo-contenedor');
const vidasContenedor = document.getElementById('vidas-contenedor');
const tiempoRecordSpan = document.getElementById('tiempo-record');

// Variables del Fantasma
let fantasmaInterval = null;
let fantasma = null; // Variable para la instancia del fantasma

// NUEVO: Variables del perro del infierno
let perroInfierno = null;
let perroInfiernoInterval = null;

function playSound(audioElement) {
    if (audioElement) {
        audioElement.currentTime = 0; // Reiniciar el audio si ya está en reproducción
        audioElement.play().catch(e => console.error("Error al reproducir audio:", e));
    }
}

function playRandomSound(audioElements) {
    const randomIndex = Math.floor(Math.random() * audioElements.length);
    playSound(audioElements[randomIndex]);
}

/* ------------ Drag vertical (solo eje Y) ------------- */
viewport.addEventListener('mousedown', (e)=>{ isDragging = true; startY = e.clientY; viewport.style.cursor = 'grabbing'; });
viewport.addEventListener('mouseup', ()=>{ isDragging = false; viewport.style.cursor = 'grab'; });
viewport.addEventListener('mouseleave', ()=>{ isDragging = false; viewport.style.cursor = 'grab'; });
viewport.addEventListener('mousemove', (e)=>{
  if (!isDragging) return;
  const dy = e.clientY - startY;
  startY = e.clientY;
  currentTop += dy;
  clampAndApplyTop();
});

function clampAndApplyTop(){
  const b = document.getElementById('board');
  const maxTop = 0;
  const minTop = viewport.clientHeight - b.clientHeight;
  if (minTop > 0) { // tablero más pequeño que viewport verticalmente
    currentTop = 0;
  } else {
    currentTop = Math.min(maxTop, Math.max(minTop, currentTop));
  }
  gameContainer.style.top = currentTop + 'px';
}

/* NUEVA FUNCION: Iniciar la musica y mostrar el menu */
function iniciarMenuJuego() {
  if (isMusicEnabled) {
    playSound(audioMusicaInicio);
  }
  startMenuDiv.style.display = 'none';
  menuDiv.style.display = 'block';
  // El tiempo y el récord se muestran solo en el modo de 1 jugador
}

// Nuevo: Funcion para alternar la musica
function toggleMusica() {
    isMusicEnabled = !isMusicEnabled;
    localStorage.setItem('musicEnabled', isMusicEnabled);
    if (isMusicEnabled) {
        botonMusica.innerHTML = '&#128266;'; // Icono de altavoz ON
        playSound(audioMusicaInicio);
    } else {
        botonMusica.innerHTML = '&#128263;'; // Icono de altavoz OFF
        audioMusicaInicio.pause();
    }
}

/* ------------ Orden inicial con desempates robustos -------------- */
function prepararOrden(num){
  menuDiv.style.display = 'none';
  ordenSalidaDiv.style.display = 'block';
  valeWrap.style.display = 'none';
  textoOrdenDiv.innerHTML = '<div>Calculando tiradas...</div>';
  
  isSinglePlayerMode = (num === 1);

  const initial = [];
  for(let i=0;i<num;i++){
    initial.push({ jugador: i, resultado: lanzarDado() });
  }
  procesarResultsIterativo(initial);
}

function procesarResultsIterativo(results){
  let html = '<h3>Resultados</h3>';
  results.forEach(r=>{
    html += `<div class="jugador-turno" style="color:${colores[r.jugador]}">Jugador ${nombresColores[colores[r.jugador]]}: ${r.resultado}</div>`;
  });

  const map = {};
  results.forEach(r => {
    if (!map[r.resultado]) map[r.resultado] = [];
    map[r.resultado].push(r.jugador);
  });

  const duplicatesGroups = Object.values(map).filter(g => g.length > 1);

  if (duplicatesGroups.length === 0) {
    const finalOrder = [...results].sort((a,b)=>b.resultado - a.resultado).map(r=>r.jugador);
    ordenJugadores = finalOrder.slice();
    html += `<hr><strong>Orden de salida:</strong><div>${ordenJugadores.map(i=>`Jugador ${nombresColores[colores[i]]}`).join(' → ')}</div>`;
    textoOrdenDiv.innerHTML = html;
    valeWrap.style.display = 'flex';
    return;
  }

  html += `<p><strong>Empates detectados:</strong></p>`;
  duplicatesGroups.forEach(g => {
    html += `<div>Empate entre: ${g.map(i=>`${nombresColores[colores[i]]}`).join(', ')}</div>`;
  });

  textoOrdenDiv.innerHTML = html;

  setTimeout(()=>{
    const newResults = results.map(r => {
      const inDup = duplicatesGroups.some(g => g.includes(r.jugador));
      if (inDup) {
        return { jugador: r.jugador, resultado: lanzarDado() };
      } else {
        return r;
      }
    });
    procesarResultsIterativo(newResults);
  }, 1200);
}

function lanzarDado(){ return Math.floor(Math.random()*6)+1; }

function confirmarOrden(){
  if (!ordenJugadores || ordenJugadores.length===0) return;
  document.getElementById('ordenSalida').style.display = 'none';
  menuDiv.style.display = 'none';
  iniciarJuego(ordenJugadores);
}

/* --------------- Iniciar juego --------------- */
function iniciarJuego(orden){
  ordenJugadores = orden.slice();
  botonTirar.style.display = 'block';
  botonTirar.disabled = false; // Habilitar el botón de tirar dado
  botonMusica.disabled = false; // Habilitar el botón de música
  mensajesJuego.style.display = 'block';
  if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
  
  jugadores = [];
  const contenedor = document.getElementById('game-container');
  contenedor.querySelectorAll('.ficha').forEach(n => n.remove());
  ordenJugadores.forEach(id => {
    const el = document.createElement('div');
    el.className = 'ficha';
    el.style.background = colores[id];
    el.dataset.id = id;
    contenedor.appendChild(el);
    jugadores.push({ id:id, ficha:el, posicion:0, activo:true, seisConsecutivos: 0, haPasado20: false }); // Inicializar contador de 6s
  });
  llegados = [];
  turnoActual = 0;
  
  // Centrar la vista en la casilla inicial al comenzar
  centrarVistaEnPosicion(0);
  
  // Limpiar cualquier fantasma o perro de la partida anterior
  if (fantasma) fantasma.element.remove();
  fantasma = null;
  if (perroInfierno) perroInfierno.element.remove();
  perroInfierno = null;
  
  colocarFichas();
  mostrarMensaje(`Turno del jugador ${nombresColores[colores[jugadores[turnoActual].id]]}`, false, colores[jugadores[turnoActual].id]);

  if (isSinglePlayerMode) {
      vidasRestantes = 3;
      actualizarVidas();
      vidasContenedor.style.display = 'flex';
      tiempoContenedor.style.display = 'block';
      tiempoRecordSpan.style.display = 'block';
      mostrarRecordTiempo();
      iniciarContador();
      iniciarFantasma();
  } else {
      vidasContenedor.style.display = 'none';
      tiempoContenedor.style.display = 'none';
      tiempoRecordSpan.style.display = 'none';
      tiempoRecordSpan.textContent = '';
  }
}

// NUEVO: Funciones para el contador de tiempo
function iniciarContador() {
    tiempoInicio = Date.now();
    timerInterval = setInterval(actualizarContador, 1000);
}
function actualizarContador() {
    const tiempoTranscurrido = Date.now() - tiempoInicio;
    const segundos = Math.floor(tiempoTranscurrido / 1000);
    const minutos = Math.floor(segundos / 60);
    const segundosRestantes = segundos % 60;
    const formattedTime = `${String(minutos).padStart(2, '0')}:${String(segundosRestantes).padStart(2, '0')}`;
    tiempoContenedor.textContent = formattedTime;
}
function detenerContador() {
    clearInterval(timerInterval);
}
function mostrarRecordTiempo() {
    const tiempoRecordActual = localStorage.getItem('tiempoRecord');
    if (tiempoRecordActual) {
        const segundos = Math.floor(tiempoRecordActual / 1000);
        const minutos = Math.floor(segundos / 60);
        const segundosRestantes = segundos % 60;
        const formattedTime = `${String(minutos).padStart(2, '0')}:${String(segundosRestantes).padStart(2, '0')}`;
        tiempoRecordSpan.textContent = `Tu mejor tiempo: ${formattedTime}`;
    } else {
        tiempoRecordSpan.textContent = 'Tu mejor tiempo: --:--';
    }
}

// NUEVO: Funciones para el contador de vidas
function actualizarVidas() {
    const vidas = [document.getElementById('vida1'), document.getElementById('vida2'), document.getElementById('vida3')];
    // Asegúrate de que las imágenes 'corazon.png', 'medio_corazon.png' y 'corazon_vacio.png'
    // existen en la carpeta img/ para que los iconos se muestren correctamente.
    for(let i=0; i<3; i++) {
        if (vidasRestantes >= i + 1) {
            vidas[i].className = 'vida-icono vida-llena';
        } else if (vidasRestantes > i) {
            vidas[i].className = 'vida-icono vida-mitad';
        } else {
            vidas[i].className = 'vida-icono vida-vacia';
        }
    }
}

function manejarPerdidaVida(cantidad){
    vidasRestantes -= cantidad;
    actualizarVidas();
    if (vidasRestantes <= 0) {
        vidasRestantes = 0;
        finalizarJuegoPorVidas();
    }
}

// NUEVO: Funciones para el fantasma
function iniciarFantasma() {
    if (fantasmaInterval) clearInterval(fantasmaInterval);
    fantasmaInterval = setInterval(crearFantasma, 5000); // Intenta crear un fantasma cada 5 segundos
    
    // Si ya hay un fantasma de la partida anterior, lo eliminamos
    const oldFantasma = document.querySelector('.fantasma');
    if (oldFantasma) oldFantasma.remove();
}

function crearFantasma() {
    if (document.querySelector('.fantasma')) return; // No crear un nuevo fantasma si ya hay uno
    if (Math.random() > 0.6) { // 40% de probabilidad de que aparezca
        const nuevaFila = Math.floor(Math.random() * 5); // 5 filas en el tablero
        const direction = Math.random() < 0.5 ? 1 : -1; // 1 para derecha, -1 para izquierda
        const fantasmaEl = document.createElement('div');
        fantasmaEl.className = 'fantasma';
        fantasmaEl.style.left = direction === 1 ? '-100px' : 'calc(100% + 100px)';
        
        const scale = board.clientWidth / diseñoOriginal.width;
        let yBase = 0;
        if (nuevaFila === 0) yBase = coords[4][1];
        else if (nuevaFila === 1) yBase = coords[14][1];
        else if (nuevaFila === 2) yBase = coords[24][1];
        else if (nuevaFila === 3) yBase = coords[34][1];
        else if (nuevaFila === 4) yBase = coords[44][1];
        
        fantasmaEl.style.top = `${yBase * scale}px`;
        gameContainer.appendChild(fantasmaEl);

        fantasma = {
            element: fantasmaEl,
            direction: direction,
            x: direction === 1 ? -100 : viewport.clientWidth + 100,
            y: yBase * scale,
            speed: 5,
            isPaused: false,
            isCollisionHandled: false // NUEVO: Bandera para evitar colisiones repetidas
        };

        fantasmaEl.style.opacity = 1;
        animarFantasma();
    }
}

function animarFantasma() {
    if (!fantasma) return;
    
    const fantasmaX = parseFloat(fantasma.element.style.left);
    const fantasmaY = parseFloat(fantasma.element.style.top);
    const fantasmaWidth = fantasma.element.offsetWidth;
    
    // Si el fantasma está en pausa, no moverlo.
    if (!fantasma.isPaused) {
        // Movimiento en zigzag
        const offset = Math.sin(Date.now() / 200) * 15;
        const newX = fantasma.x + fantasma.direction * fantasma.speed;
        const newY = fantasma.y + offset;
        
        fantasma.x = newX;
        fantasma.y = newY;
    
        fantasma.element.style.left = `${newX}px`;
        fantasma.element.style.top = `${newY}px`;
    }
    
    // Colisión
    const jugador = jugadores[0];
    const ficha = jugador.ficha;
    const fichaRect = ficha.getBoundingClientRect();
    const fantasmaRect = fantasma.element.getBoundingClientRect();

    const isColliding = fichaRect.left < fantasmaRect.right && fichaRect.right > fantasmaRect.left && fichaRect.top < fantasmaRect.bottom && fichaRect.bottom > fantasmaRect.top;
    
    // Si hay una colisión y no se ha manejado ya para este fantasma
    if (isColliding && !fantasma.isCollisionHandled) {
        fantasma.isCollisionHandled = true; // Marcar la colisión como manejada
        if (casillasSegurasFantasma.includes(jugador.posicion)) {
            fantasma.isPaused = true;
            mostrarTextoEspecial('¡Estás protegido del fantasma!', colores[jugador.id], 1500);
            setTimeout(() => {
                fantasma.isPaused = false;
                // Mover el fantasma ligeramente para "romper" la colisión
                fantasma.x += fantasma.direction * 30; 
                animarFantasma(); // Reanudar la animación manualmente
            }, 2000);
            // No hay return aquí, ya que el requestAnimationFrame se llama al final
        } else {
            // Colisión normal
            manejarColisionFantasma(jugador);
        }
    }
    
    // Remover fantasma si se sale de la pantalla
    const screenWidth = viewport.clientWidth;
    if (fantasma.x < -fantasmaWidth || fantasma.x > screenWidth) {
        fantasma.element.remove();
        fantasma = null;
        return;
    }
    
    requestAnimationFrame(animarFantasma);
}

function manejarColisionFantasma(jugador) {
    if (!fantasma) return;
    
    // Centrar la vista en la colisión antes de la animación
    centrarSiEsNecesario(jugador);
    
    // Iniciar sonido y animación
    playSound(audioFantasma);
    fantasma.element.classList.add('fantasma-colision');
    
    // Esperar a que el fantasma desaparezca antes de aplicar la lógica de juego
    setTimeout(()=>{
        mostrarTextoEspecial('¡Un fantasma te ha golpeado!', colores[jugador.id], 2500);
        manejarPerdidaVida(0.5);
        if (fantasma) fantasma.element.remove();
        fantasma = null;
    }, 700);
}


// NUEVO: Funciones del Perro del Infierno
function crearPerroInfierno() {
    if (perroInfierno) return;

    const perroEl = document.createElement('div');
    perroEl.className = 'perro-infierno';
    gameContainer.appendChild(perroEl);

    perroInfierno = {
        element: perroEl,
        posicion: 1, // Inicia en la casilla 1
        isMoving: false,
    };
    
    perroEl.style.opacity = 1;
    colocarPerro();
    perroInfiernoInterval = setInterval(moverPerro, 3000);
}

function colocarPerro() {
    if (!perroInfierno) return;
    const pos = perroInfierno.posicion;
    const [xBase, yBase] = coords[pos];
    const scale = board.clientWidth / diseñoOriginal.width;
    perroInfierno.element.style.left = `${xBase * scale}px`;
    perroInfierno.element.style.top = `${yBase * scale}px`;
}

// Lógica de movimiento del perro actualizada
function moverPerro() {
    if (!perroInfierno || perroInfierno.isMoving) return;
    
    perroInfierno.isMoving = true;
    const avance = Math.floor(Math.random() * 5) + 1; // Dado de 1 a 5
    let posFinal = perroInfierno.posicion + avance;
    
    // Si el perro llega o supera la casilla 52, vuelve a 0
    if (posFinal >= 52) {
        posFinal = 0;
        mostrarTextoEspecial('¡El Perro del Infierno ha vuelto a la casilla inicial!', 'red', 2500);
    }
    
    animarMovimientoPerro(perroInfierno, posFinal, () => {
        perroInfierno.posicion = posFinal;
        
        // Comprobar colisiones
        for (const jugador of jugadores.filter(j => j.activo)) {
            if (jugador.posicion === perroInfierno.posicion) {
                manejarColisionPerro(jugador);
                break; // Solo afecta a un jugador por turno del perro
            }
        }
        
        // El perro ya no se elimina, el ciclo se repite
        perroInfierno.isMoving = false;
    });
}

function animarMovimientoPerro(perro, posDestino, callback) {
    const scale = board.clientWidth / diseñoOriginal.width;
    const [x, y] = coords[posDestino];
    
    perro.element.style.transition = 'all 1.5s ease-in-out';
    perro.element.style.left = `${x * scale}px`;
    perro.element.style.top = `${y * scale}px`;

    setTimeout(() => {
        perro.element.style.transition = 'none';
        callback();
    }, 1500);
}

function manejarColisionPerro(jugador) {
    const nombreJugador = nombresColores[colores[jugador.id]];
    const colorJugador = colores[jugador.id];

    // NUEVO: Comprobar si el jugador está en una casilla de seguridad
    if (isSinglePlayerMode && casillasSegurasFantasma.includes(jugador.posicion)) {
        mostrarTextoEspecial(`¡${nombreJugador} está protegido del Perro del Infierno!`, colorJugador, 2500);
        finalizarTurno(jugador, 0, false);
    } else {
        // Lógica de retroceso si no está en una casilla de seguridad
        playSound(audioPerro);
        mostrarTextoEspecial(`¡${nombreJugador} ha chocado con el Perro del Infierno! Retrocedes 5 casillas.`, colorJugador, 2500);

        let nuevaPos = Math.max(0, jugador.posicion - 5);
        
        animarMovimiento(jugador, nuevaPos, () => {
            jugador.posicion = nuevaPos;
            colocarFichas();
            
            const casillaEspecial = especiales[jugador.posicion];
            if (casillaEspecial) {
                if (casillaEspecial.tipo === 'retroceso' || casillaEspecial.tipo === 'gozer') {
                    // Si es una casilla de retroceso o Gozer, se aplica
                    manejarCasillaEspecial(jugador, null, false);
                } else {
                    // Si es de avance, se ignora
                    mostrarMensaje(`Jugador ${nombreJugador} retrocede y se salva de un avance.`, false, colorJugador);
                    finalizarTurno(jugador, 0, false);
                }
            } else {
                finalizarTurno(jugador, 0, false);
            }
        });
    }
}


/* --------------- colocar fichas (muestra todas incluidas las llegadas) --------------- */
function colocarFichas(){
  const img = document.getElementById('board');
  const scale = img.clientWidth / diseñoOriginal.width;
  const ocupadas = {};
  jugadores.forEach(j => {
    const key = `c${j.posicion}`;
    if (!ocupadas[key]) ocupadas[key] = [];
    ocupadas[key].push(j);
  });
  for (const key in ocupadas){
    const grupo = ocupadas[key];
    const pos = parseInt(key.slice(1));
    const [xBase,yBase] = coords[pos];
    grupo.forEach((jugador,i)=>{
      const x = (xBase * scale);
      const y = (yBase * scale);
      const offsetAngle = (i % 4);
      const dx = ((offsetAngle === 0 || offsetAngle === 3) ? -12 : 12) + (Math.floor(i/4)*6);
      const dy = ((offsetAngle === 0 || offsetAngle === 1) ? -12 : 12) + (Math.floor(i/4)*6);
      jugador.ficha.style.left = `${x}px`;
      jugador.ficha.style.top  = `${y}px`;
      jugador.ficha.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    });
  }
  // Colocar al perro si existe
  if(perroInfierno) colocarPerro();
}

/* --------------- Mensajes temporales --------------- */
function mostrarMensaje(texto, temporal = true, color = '#fff') {
    if (mensajeTimer) clearTimeout(mensajeTimer);
    mensajesJuego.innerHTML = texto;
    mensajesJuego.style.opacity = 1;
    mensajesJuego.style.color = color;
    if (temporal) {
        mensajeTimer = setTimeout(() => {
            mensajesJuego.style.opacity = 0;
        }, 4000);
    }
}

/* NUEVO: Función para mostrar texto de acción especial */
function mostrarTextoEspecial(texto, color = 'gold', duracion = 2500) {
    const contenedor = document.getElementById('viewport');
    const textoEl = document.createElement('div');
    textoEl.className = 'texto-especial';
    textoEl.textContent = texto;
    textoEl.style.color = color;
    contenedor.appendChild(textoEl);
    
    setTimeout(() => {
        textoEl.remove();
    }, duracion);
}

/* --------------- movimiento: tirar dado y reglas --------------- */
function simularTirada(){
  clearTimeout(mensajeTimer);
  mensajesJuego.style.opacity = 0;
  botonTirar.classList.add('animando');
  botonTirar.disabled = true;
  botonMusica.disabled = true;

  if (jugadores.length === 0) return;
  let attempts = 0;
  while (attempts < jugadores.length && !jugadores[turnoActual].activo){
    turnoActual = (turnoActual + 1) % jugadores.length;
    attempts++;
  }
  if (attempts >= jugadores.length) return;

  const jugador = jugadores[turnoActual];
  const colorJugador = colores[jugador.id];
  const nombreJugador = nombresColores[colorJugador];

  // Centrar la vista en el jugador actual antes de tirar el dado
  centrarSiEsNecesario(jugador);
  
  // Retraso para que la vista se centre antes de iniciar la tirada
  setTimeout(() => {
    botonTirar.classList.remove('animando');

    // Reproducir sonido de tirada de dado
    playSound(audioTiradaDado);

    // Mostrar el dado girando
    dadoContenedor.style.display = 'block';
    dadoElemento.classList.remove('girando-final-1', 'girando-final-2', 'girando-final-3', 'girando-final-4', 'girando-final-5', 'girando-final-6');
    dadoElemento.className = 'dado girando';
    
    // Retraso para que la animación de giro sea visible
    setTimeout(() => {
      const avance = lanzarDado();
      const posInicial = jugador.posicion;
      let posNueva = posInicial + avance;

      dadoElemento.classList.remove('girando');
      dadoElemento.classList.add(`girando-final-${avance}`);
      
      // Retraso para que el jugador vea el resultado del dado
      setTimeout(() => {
        dadoContenedor.style.display = 'none';

        let esSeis = false;
        // Lógica de los tres 6 seguidos
        if (avance === 6) {
            esSeis = true;
            playSound(audioDado6);
            jugador.seisConsecutivos++;
            let mensajeDado = '';
            if (jugador.seisConsecutivos === 1) {
                mensajeDado = `¡${nombreJugador} ha sacado un 6, vuelve a tirar!`;
            } else if (jugador.seisConsecutivos === 2) {
                mensajeDado = `¡${nombreJugador}, vuelve a tirar, pero cuidado!`;
            } else if (jugador.seisConsecutivos === 3) {
                mensajeDado = `¡${nombreJugador} se ha socarrado, a la casilla de salida!`;
                posNueva = 0;
                jugador.seisConsecutivos = 0;
            }
            mostrarTextoEspecial(mensajeDado, colorJugador, 2500);
        } else {
            jugador.seisConsecutivos = 0;
            mostrarMensaje(`Jugador ${nombreJugador} ha sacado un ${avance}.`, true, colorJugador);
        }
        
        animarMovimiento(jugador, posNueva >= 52 ? 52 : posNueva, () => {
          jugador.posicion = posNueva >= 52 ? 52 : posNueva;
          
          // Lógica para que aparezca el perro, ahora en cualquier modo
          if (!perroInfierno && jugadores.some(j => j.posicion >= 20)) {
              crearPerroInfierno();
          }
          
          if (posNueva >= 52) {
              llegados.push(jugador.id);
              jugador.activo = false;
              jugador.ficha.classList.add('ficha-levantada');
              mostrarMensaje(`¡Jugador ${nombreJugador} ha llegado a la meta!`, false, colorJugador);
              playSound(audioLlegadaMeta);
              
              const jugadoresActivos = jugadores.filter(j => j.activo);
              // Lógica corregida para el final de la partida
              if (jugadoresActivos.length <= 1) {
                  mostrarFinal();
              } else {
                  finalizarTurno(jugador, avance, esSeis);
              }
          } else {
            const casillaEspecial = especiales[jugador.posicion];
            if (casillaEspecial) {
              manejarCasillaEspecial(jugador, avance, esSeis);
            } else {
                // Si sacó 6 y no hay casilla especial, vuelve a tirar
                if(esSeis && jugador.seisConsecutivos < 3) {
                    mostrarMensaje(`Turno del jugador ${nombreJugador} de nuevo (sacó un 6).`, false, colorJugador);
                    botonTirar.disabled = false;
                    botonMusica.disabled = false;
                } else {
                    finalizarTurno(jugador, avance, esSeis);
                }
            }
          }
        });
      }, 2000); // Duración de la animación final del dado
    }, 1000); // Duración de la animación de giro
  }, 700); // Duración del centrado de la cámara (Ajustado de 500ms a 700ms)
}

function animarMovimiento(jugador, posDestino, callback){
  const posInicial = jugador.posicion;
  const paso = posInicial < posDestino ? 1 : -1;
  const esEspecial = especiales[posDestino];
  
  if (posInicial === posDestino) {
    if (callback) callback();
    return;
  }
  
  const timer = setInterval(()=>{
    const nuevaPos = jugador.posicion + paso;
    jugador.posicion = nuevaPos;
    colocarFichas();
    
    // Mover la cámara para seguir a la ficha en cada paso
    centrarVistaEnPosicion(jugador.posicion);

    // Reproducir sonidos de movimiento
    if (esEspecial && (esEspecial.tipo === 'avance' || esEspecial.tipo === 'retroceso')) {
        if (paso === 1) playRandomSound([audioSubida1, audioSubida2]);
        else playRandomSound([audioBajada1, audioBajada2]);
    }

    if (nuevaPos === posDestino){
      clearInterval(timer);
      if (callback) callback();
    }
  }, 100);
}

/* --------------- reglas de casillas especiales --------------- */
function manejarCasillaEspecial(jugador, avance, esSeis) {
    const nombreJugador = nombresColores[colores[jugador.id]];
    const colorJugador = colores[jugador.id];
    const casillaEspecial = especiales[jugador.posicion];
    if (!casillaEspecial) {
        finalizarTurno(jugador, avance, esSeis);
        return;
    }

    let texto = '';
    let playSoundGozer = false;

    if (casillaEspecial.tipo === 'avance') {
        texto = `¡Genial! Jugador ${nombreJugador} avanza a la casilla ${casillaEspecial.destino}!`;
    } else if (casillaEspecial.tipo === 'retroceso') {
        texto = `¡Oh no! Jugador ${nombreJugador} retrocede a la casilla ${casillaEspecial.destino}.`;
    } else if (casillaEspecial.tipo === 'gozer') {
        texto = `¡El Jugador ${nombreJugador} se encuentra con Gozer! Vuelve a la casilla de salida.`;
        playSoundGozer = true;
    }
    
    // Centrar la vista en la casilla especial
    centrarSiEsNecesario(jugador);

    // Mover la ficha levantada mientras se centra la vista
    jugador.ficha.classList.add('ficha-levantada');
    
    setTimeout(() => {
        mostrarTextoEspecial(texto, colorJugador, 2500);
        
        // Brillo de la casilla especial
        const resplandor = document.createElement('div');
        resplandor.className = 'casilla-resplandor ' + (casillaEspecial.tipo === 'avance' ? 'brillo-verde' : (casillaEspecial.tipo === 'gozer' ? 'brillo-gozer' : 'brillo-rojo'));
        gameContainer.appendChild(resplandor);
        const [xBase, yBase] = coords[jugador.posicion];
        const scale = board.clientWidth / diseñoOriginal.width;
        resplandor.style.left = `${xBase * scale}px`;
        resplandor.style.top = `${yBase * scale}px`;

        if(playSoundGozer) playSound(audioGozer);
        
        setTimeout(()=>{
          resplandor.remove();
          animarMovimiento(jugador, casillaEspecial.destino, ()=>{
            jugador.posicion = casillaEspecial.destino;
            colocarFichas();
            jugador.ficha.classList.remove('ficha-levantada'); // Baja la ficha
            
            // NUEVO: Centrar la vista en la nueva posición de la ficha
            centrarVistaEnPosicion(jugador.posicion);

            setTimeout(() => {
                // Volvemos a comprobar si la nueva casilla es especial
                const nuevaCasillaEspecial = especiales[jugador.posicion];
                if (nuevaCasillaEspecial && (nuevaCasillaEspecial.tipo === 'avance' || nuevaCasillaEspecial.tipo === 'retroceso')) {
                  // Si cae en una casilla especial después de un avance/retroceso, no se aplica su efecto
                  mostrarMensaje(`Jugador ${nombreJugador} se salva del efecto de la nueva casilla.`, false, colorJugador);
                  // Si sacó 6, vuelve a tirar
                  if (esSeis && jugador.seisConsecutivos < 3) {
                      mostrarMensaje(`Turno del jugador ${nombreJugador} de nuevo (sacó un 6).`, false, colorJugador);
                      botonTirar.disabled = false;
                      botonMusica.disabled = false;
                  } else {
                      finalizarTurno(jugador, avance, esSeis);
                  }
                } else {
                    if (esSeis && jugador.seisConsecutivos < 3) {
                        mostrarMensaje(`Turno del jugador ${nombreJugador} de nuevo (sacó un 6).`, false, colorJugador);
                        botonTirar.disabled = false;
                        botonMusica.disabled = false;
                    } else {
                        finalizarTurno(jugador, avance, esSeis);
                    }
                }
            }, 700); // Pequeña espera para el centrado de la cámara
          });
        }, 2500); // Espera a que el mensaje especial desaparezca
    }, 1500); // Espera a que la cámara se haya movido
}

/* --------------- Final de turno y juego --------------- */
function finalizarTurno(jugador, avance, esSeis){
  const jugadoresActivos = jugadores.filter(j => j.activo);

  // Lógica de pase de turno
  if (esSeis && jugador.seisConsecutivos < 3 && !llegados.includes(jugador.id)) {
    mostrarMensaje(`Turno del jugador ${nombresColores[colores[jugador.id]]} de nuevo (sacó un 6).`, false, colores[jugador.id]);
  } else {
    turnoActual = (turnoActual + 1) % jugadores.length;
    let attempts = 0;
    while(attempts < jugadores.length && !jugadores[turnoActual].activo){
      turnoActual = (turnoActual + 1) % jugadores.length;
      attempts++;
    }
    // Lógica corregida para el final de la partida
    if (jugadoresActivos.length <= 1) {
        mostrarFinal();
        return;
    }
    mostrarMensaje(`Turno del jugador ${nombresColores[colores[jugadores[turnoActual].id]]}.`, false, colores[jugadores[turnoActual].id]);
  }
  botonTirar.disabled = false;
  botonMusica.disabled = false;
}

function finalizarJuegoPorVidas() {
    detenerContador();
    if (fantasmaInterval) clearInterval(fantasmaInterval);
    if (fantasma) fantasma.element.remove();
    if (perroInfiernoInterval) clearInterval(perroInfiernoInterval);
    
    // Centrar la vista en el jugador antes de mostrar el modal
    if (jugadores.length > 0 && jugadores[0].activo) {
      centrarVistaEnPosicion(jugadores[0].posicion);
    }
    
    // Ocultar elementos de juego
    botonTirar.style.display = 'none';
    mensajesJuego.style.display = 'none';
    vidasContenedor.style.display = 'none';
    tiempoContenedor.style.display = 'none';
    tiempoRecordSpan.style.display = 'none';
    dadoContenedor.style.display = 'none';

    // Habilitar botón de música antes de terminar
    botonMusica.disabled = false;

    // Mostrar modal de fin de juego
    finalModal.innerHTML = '<h3>¡Fin del juego!</h3><p>Te quedaste sin vidas.</p><div class="modal-buttons"><button onclick="reiniciarJuego()">Volver a jugar</button></div>';
    finalModal.style.display = 'block';
}

function mostrarFinal(){
  if (perroInfiernoInterval) clearInterval(perroInfiernoInterval);
  
  detenerContador();
  if (fantasmaInterval) clearInterval(fantasmaInterval);
  if (fantasma) fantasma.element.remove();
  
  // Centrar la vista en la casilla final
  if (jugadores.length > 0) {
    centrarVistaEnPosicion(52);
  }
  
  let html = '<h3>Fin de la partida</h3>';
  if (isSinglePlayerMode) {
      // Modo un jugador, el jugador llegó a la meta
      const tiempoFinal = Date.now() - tiempoInicio;
      const segundos = Math.floor(tiempoFinal / 1000);
      const minutos = Math.floor(segundos / 60);
      const segundosRestantes = segundos % 60;
      const formattedTime = `${String(minutos).padStart(2, '0')}:${String(segundosRestantes).padStart(2, '0')}`;
      
      const tiempoRecordActual = localStorage.getItem('tiempoRecord');
      let esRecord = false;
      if (!tiempoRecordActual || tiempoFinal < parseInt(tiempoRecordActual)) {
          localStorage.setItem('tiempoRecord', tiempoFinal);
          esRecord = true;
      }
      
      html += `<p>¡Enhorabuena, has llegado a la meta!</p><p>Tu tiempo: ${formattedTime}</p>`;
      if (esRecord) {
          html += `<p>¡NUEVO RÉCORD!</p>`;
      }
      html += `<div class="modal-buttons"><button onclick="reiniciarJuego()">Volver a jugar</button></div>`;
  } else {
    // Modo multijugador, orden de llegada
    llegados.forEach((id,i)=>{
      html+=`<p>${i+1}º: Jugador ${nombresColores[colores[id]]}</p>`;
    });
    // Si aún quedan jugadores activos (solo 1), añadimos su posición final
    const jugadoresActivosFinal = jugadores.filter(j => j.activo);
    if(jugadoresActivosFinal.length > 0) {
        html+=`<p>${llegados.length+1}º: Jugador ${nombresColores[colores[jugadoresActivosFinal[0].id]]}</p>`;
    }
    html += '<div class="modal-buttons"><button onclick="reiniciarJuego()">Volver a jugar</button></div>';
  }
  
  finalModal.innerHTML = html;
  finalModal.style.display = 'block';

  botonTirar.style.display = 'none';
  mensajesJuego.style.display = 'none';
  dadoContenedor.style.display = 'none';

  // Habilitar botón de música antes de terminar
  botonMusica.disabled = false;
}

function reiniciarJuego(){
  // Ocultar modales y elementos de juego
  finalModal.style.display = 'none';
  document.getElementById('ordenSalida').style.display = 'none';
  botonTirar.style.display = 'none';
  mensajesJuego.style.display = 'none';
  vidasContenedor.style.display = 'none';
  tiempoContenedor.style.display = 'none';
  tiempoRecordSpan.style.display = 'none';
  dadoContenedor.style.display = 'none';

  // Eliminar fichas
  const contenedor = document.getElementById('game-container');
  contenedor.querySelectorAll('.ficha').forEach(n => n.remove());

  // Limpiar fantasma
  if (fantasma) fantasma.element.remove();
  fantasma = null;
  if (fantasmaInterval) clearInterval(fantasmaInterval);
  
  // Limpiar perro
  if (perroInfierno) perroInfierno.element.remove();
  perroInfierno = null;
  if (perroInfiernoInterval) clearInterval(perroInfiernoInterval);
  
  // Resetear el estado
  jugadores = [];
  ordenJugadores = [];
  llegados = [];
  turnoActual = 0;
  isSinglePlayerMode = false;
  
  // Mostrar menú principal
  menuDiv.style.display = 'block';
  startMenuDiv.style.display = 'none';
}

/* --------------- utilidades --------------- */
// Centra la vista en una ficha específica si no está ya en pantalla
function centrarSiEsNecesario(jugador) {
    const fichaRect = jugador.ficha.getBoundingClientRect();
    const viewportRect = viewport.getBoundingClientRect();
    const gameContainerRect = gameContainer.getBoundingClientRect();
    
    const fichaTop = fichaRect.top - gameContainerRect.top;
    const fichaBottom = fichaRect.bottom - gameContainerRect.top;
    
    if (fichaTop < 0 || fichaBottom > viewportRect.height) {
        const offset = (viewportRect.height / 2) - fichaRect.height;
        currentTop = -(fichaTop - offset);
        clampAndApplyTop();
    }
}

// Nueva función para centrar la vista en una posición de casilla específica
function centrarVistaEnPosicion(posicion) {
    if (posicion < 0 || posicion >= coords.length) return;
    const [x, y] = coords[posicion];
    const scale = board.clientWidth / diseñoOriginal.width;
    const centerY = (y * scale);
    const viewportHeight = viewport.clientHeight;
    
    currentTop = (viewportHeight / 2) - centerY;
    clampAndApplyTop();
}

// Escuchador de redimensionado para recalcular la posición de las fichas y el zoom
window.addEventListener('resize', () => {
  colocarFichas();
  clampAndApplyTop();
});

// Inicializar el estado de la música al cargar
document.addEventListener('DOMContentLoaded', () => {
    if (isMusicEnabled) {
        botonMusica.innerHTML = '&#128266;'; // Icono de altavoz ON
    } else {
        botonMusica.innerHTML = '&#128263;'; // Icono de altavoz OFF
    }
    // Muestra el menú de inicio por defecto
    startMenuDiv.style.display = 'block';
});
</script>
</body>
</html>