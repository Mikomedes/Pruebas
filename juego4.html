<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Puzzle Ghostbusters</title>
  <style>
    body {
      margin: 0;
      font-family: 'Quicksand', sans-serif;
      background-color: #f0f8ff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow: hidden;
    }

    h1 {
      font-size: 1.5rem;
      color: #444;
      margin: 0.5rem;
    }

    #menu {
      margin: 0.5rem;
      text-align: center;
    }

    button {
      padding: 0.7rem 1.5rem;
      margin: 0.5rem;
      font-size: 1rem;
      border: none;
      border-radius: 12px;
      background-color: #cce0dd;
      color: #333;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    button:hover {
      background-color: #b0d2cb;
    }

    #preview {
      max-width: 300px;
      width: 90%;
      margin: 0.5rem auto;
      border-radius: 12px;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
    }

    #puzzle-container {
      position: relative;
      width: 90vmin;
      height: 90vmin;
      max-width: 90vw;
      max-height: 90vh;
      background-color: #e0f7f4;
      overflow: hidden;
      display: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #info {
      margin-top: 0.5rem;
      font-size: 1rem;
      color: #444;
    }

    #restart {
      display: none;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <h1>üß© Puzzle Ghostbusters</h1>
  <div id="menu">
    <p>Imagen final del puzzle:</p>
    <img id="preview" src="imagen/ghostpuzzle.jpg" alt="Vista previa del puzzle" />
    <p>Selecciona dificultad:</p>
    <button onclick="startGame(3)">F√°cil (3x3)</button>
    <button onclick="startGame(4)">Normal (4x4)</button>
  </div>
  <div id="puzzle-container">
    <canvas id="puzzle"></canvas>
  </div>
  <div id="info"></div>
  <button id="restart" onclick="location.reload()">üîÅ Reiniciar</button>

  <script>
    const imgSrc = "imagen/ghostpuzzle.jpg";
    let canvas = document.getElementById("puzzle");
    let ctx = canvas.getContext("2d");
    let pieces = [];
    let boardSize, pieceSize, rows, cols, img;
    let dragging = null, offsetX = 0, offsetY = 0;
    let startTime, timerRunning = false;
    let difficulty;

    function startGame(n) {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      }
      document.getElementById("menu").style.display = "none";
      document.getElementById("puzzle-container").style.display = "block";
      rows = cols = n;
      difficulty = n + "x" + n;
      img = new Image();
      img.onload = () => {
        setupPuzzle();
        drawPuzzle();
        startTimer();
      };
      img.src = imgSrc;
    }

    function setupPuzzle() {
      canvas.width = canvas.height = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardSize = canvas.width;
      pieceSize = boardSize / rows;
      pieces = [];

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          pieces.push({
            sx: x * (img.width / cols),
            sy: y * (img.height / rows),
            x: Math.random() * (boardSize - pieceSize),
            y: Math.random() * (boardSize - pieceSize),
            row: y,
            col: x,
            placed: false
          });
        }
      }

      canvas.addEventListener("mousedown", startDrag);
      canvas.addEventListener("mousemove", drag);
      canvas.addEventListener("mouseup", endDrag);
      canvas.addEventListener("touchstart", startDrag, {passive:false});
      canvas.addEventListener("touchmove", drag, {passive:false});
      canvas.addEventListener("touchend", endDrag);
    }

    function drawPuzzle() {
      ctx.clearRect(0, 0, boardSize, boardSize);

      // Dibujar primero las piezas colocadas correctamente (bottom layer)
      for (let p of pieces) {
        if (p.placed) {
          ctx.drawImage(img, p.sx, p.sy, img.width / cols, img.height / rows, p.x, p.y, pieceSize, pieceSize);
        }
      }

      // Dibujar luego las piezas no colocadas (top layer)
      for (let p of pieces) {
        if (!p.placed) {
          ctx.drawImage(img, p.sx, p.sy, img.width / cols, img.height / rows, p.x, p.y, pieceSize, pieceSize);
          ctx.strokeStyle = "#ccc";
          ctx.strokeRect(p.x, p.y, pieceSize, pieceSize);
        }
      }
    }

    function startDrag(e) {
      e.preventDefault();
      let pos = getMousePos(e);
      // Iterar desde el final para coger la pieza superior
      for (let i = pieces.length - 1; i >= 0; i--) {
        let p = pieces[i];
        // Solo permitir arrastrar piezas que NO est√°n colocadas
        if (!p.placed &&
            pos.x >= p.x && pos.x <= p.x + pieceSize &&
            pos.y >= p.y && pos.y <= p.y + pieceSize) {
          dragging = p;
          offsetX = pos.x - p.x;
          offsetY = pos.y - p.y;
          // Mueve la pieza que se est√° arrastrando al final del array
          // para que se dibuje encima de todas las dem√°s
          pieces.splice(i, 1);
          pieces.push(p);
          break;
        }
      }
    }

    function drag(e) {
      if (!dragging) return;
      e.preventDefault();
      let pos = getMousePos(e);
      dragging.x = pos.x - offsetX;
      dragging.y = pos.y - offsetY;
      drawPuzzle();
    }

    function endDrag() {
      if (!dragging) return;
      let correctX = dragging.col * pieceSize;
      let correctY = dragging.row * pieceSize;
      if (Math.abs(dragging.x - correctX) < pieceSize / 5 && Math.abs(dragging.y - correctY) < pieceSize / 5) {
        dragging.x = correctX;
        dragging.y = correctY;
        dragging.placed = true;
      }
      dragging = null;
      drawPuzzle();
      checkWin();
    }

    function getMousePos(e) {
      let rect = canvas.getBoundingClientRect();
      let scaleX = canvas.width / rect.width;
      let scaleY = canvas.height / rect.height;
      if (e.touches && e.touches.length > 0) {
        return {
          x: (e.touches[0].clientX - rect.left) * scaleX,
          y: (e.touches[0].clientY - rect.top) * scaleY
        };
      } else {
        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY
        };
      }
    }

    function startTimer() {
      startTime = Date.now();
      timerRunning = true;
    }

    function checkWin() {
      if (pieces.every(p => p.placed)) {
        let time = ((Date.now() - startTime) / 1000).toFixed(1);
        let recordKey = "record_" + difficulty;
        let record = localStorage.getItem(recordKey);
        if (!record || parseFloat(time) < parseFloat(record)) {
          localStorage.setItem(recordKey, time);
          record = time;
        }
        document.getElementById("info").innerText = `¬°Puzzle completado en ${time} segundos! üèÅ\nMejor tiempo (${difficulty}): ${record} s`;
        document.getElementById("restart").style.display = "inline-block";
      }
    }
  </script>
</body>
</html>
